# file      : tests/pkg-status.test
# copyright : Copyright (c) 2014-2017 Code Synthesis Ltd
# license   : MIT; see accompanying LICENSE file

.include common.test config.test remote.test remote-git.test

# Source repository:
#
# pkg-status
# |-- extra                     -> stable (prerequisite)
# |   |-- libbar-1.1.0+1.tar.gz
# |   `-- repositories.manifest
# |
# |-- stable
# |   |-- libbar-1.0.0.tar.gz
# |   |-- libfoo-1.0.0.tar.gz
# |   `-- repositories.manifest
# |
# |-- testing                   -> stable (complement), extra (prerequisite)
# |   |-- libbar-1.0.0+1.tar.gz
# |   |-- libbar-1.1.0.tar.gz
# |   `-- repositories.manifest
# |
# |-- unstable                  -> testing (complement)
# |   |-- libbar-2.0.0.tar.gz
# |   `-- repositories.manifest
# |
# `-- git
#     |-- libbar.git            -> style-basic.git (prerequisite)
#     |-- style-basic.git
#     `-- style.git

# Prepare repositories used by tests if running in the local mode.
#
+if ($remote != true)
  cp -r $src/extra    $out/extra
  cp -r $src/stable   $out/stable
  cp -r $src/testing  $out/testing
  cp -r $src/unstable $out/unstable

  c = $rep_create 2>!

  $c $out/extra    &$out/extra/packages.manifest
  $c $out/stable   &$out/stable/packages.manifest
  $c $out/testing  &$out/testing/packages.manifest
  $c $out/unstable &$out/unstable/packages.manifest

  # Create git repositories.
  #
  $git_extract $src/git/style.tar
  $git_extract $src/git/libbar.tar
  $git_extract $src/git/style-basic.tar &$out_git/state0/***
end

pkg_fetch  += 2>!
pkg_purge  += -d cfg 2>!
rep_add    += -d cfg 2>!
rep_fetch  += -d cfg --auth all --trust-yes 2>!

: basics
:
{
  +$clone_cfg

  : not-fetched
  :
  {
    +$clone_cfg

    : libfoo-1.0.0
    :
    $clone_cfg;
    $* libfoo/1.0.0 >'unknown'

    : libfoo
    :
    $clone_cfg;
    $* libfoo >'unknown'
  }

  : rep-fetched
  :
  {
    +$clone_cfg && $rep_add $rep/stable && $rep_fetch

    +cp -r cfg ./fetched
    +$pkg_fetch libfoo/1.0.0 -d fetched &fetched/libfoo-1.0.0.tar.gz

    : libfoo-1.0.0
    :
    $clone_cfg;
    $* libfoo/1.0.0 >'available'

    : libfoo
    :
    $clone_cfg;
    $* libfoo >'available 1.0.0 sys:?'

    : pkg-fetched
    :
    {
      clone_cfg = cp -r ../../fetched cfg

      : libfoo-1.0.0
      :
      $clone_cfg;
      $* libfoo/1.0.0 >'fetched; available'

      : libfoo
      :
      $clone_cfg;
      $* libfoo >'fetched 1.0.0; available sys:?'
    }
  }
}

: multiple-versions
{
  # Prepare the nested tests to copy the root configuration. Note that they
  # must provide the destination directory name as an argument.
  #
  clone_cfg = cp -r $~/../cfg

  : extra
  :
  {
    # Here we, first, prepare 2 configurations that derive from each other, and
    # then spawn 2 tests on them.
    #
    +$clone_cfg extra && $rep_add -d extra $rep/extra && $rep_fetch -d extra

    +cp -r extra extra-stable
    +$rep_add -d extra-stable $rep/stable && $rep_fetch -d extra-stable

    : libbar
    :
    $* -d ../extra libbar >'available 1.1.0+1 sys:?'

    : libbar-stable
    :
    $* -d ../extra-stable libbar >'available 1.1.0+1 1.0.0 sys:?'
  }

  : testing
  :
  {
    $clone_cfg ./ && $rep_add $rep/testing && $rep_fetch;

    $* libbar >'available 1.1.0 1.0.0+1 1.0.0 sys:?'
  }

  : unstable
  :
  {
    # Here we, first, prepare 3 configurations that derive from each other, and
    # then spawn 3 tests on them.
    #
    +$clone_cfg ./ && $rep_add $rep/unstable && $rep_fetch

    +cp -r cfg fetched1
    +$pkg_fetch libbar/1.0.0+1 -d fetched1 &fetched1/libbar-1.0.0+1.tar.gz

    +cp -r fetched1 fetched2
    +$pkg_purge -d fetched2 libbar &!fetched2/libbar-1.0.0+1.tar.gz
    +$pkg_fetch libbar/2.0.0 -d fetched2 &fetched2/libbar-2.0.0.tar.gz

    : not-fetched
    :
    $* -d ../cfg libbar >'available 2.0.0 1.1.0 1.0.0+1 1.0.0 sys:?'

    : fetched-1
    :
    $* -d ../fetched1 libbar >'fetched 1.0.0+1; available 2.0.0 1.1.0 sys:?'

    : fetched-2
    :
    $* -d ../fetched2 libbar >'fetched 2.0.0; available sys:?'
  }
}

: git-rep
:
if ($git_supported != true)
{
  # Skip git repository tests.
  #
}
else
{
  rep = "$rep_git/state0"
  test.cleanups += &cfg/.bpkg/repos/*/***

  : complement-cycle
  :
  : Make sure that we properly handle the root<->style repository dependency
  : cycle while searching for the style-basic package, that is an available
  : package but not from the user-added repository (or its complement), and so
  : is not visible for the status command. Note that the root repository is the
  : default complement for git repositories (see rep_fetch() implementation for
  : the reasoning).
  :
  $clone_root_cfg;
  $rep_add "$rep/libbar.git#master" && $rep_add "$rep/style.git#master";

  # Convert specific warnings to infos as we expect them to appear. This, in
  # particular, prevents bbot workers to set task result status to warning.
  #
  $rep_fetch 2>&1 | \
  sed -e 's/warning: (fetching (over|whole) .*)/info: \1/' >&2 2>!;

  $* style-basic >'unknown'
}
