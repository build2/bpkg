// file      : bpkg/package -*- C++ -*-
// copyright : Copyright (c) 2014-2015 Code Synthesis Ltd
// license   : MIT; see accompanying LICENSE file

#ifndef BPKG_PACKAGE
#define BPKG_PACKAGE

#include <set>
#include <vector>
#include <cstdint> // uint16
#include <ostream>

#include <odb/core.hxx>

#include <bpkg/manifest>

#include <bpkg/types>
#include <bpkg/utility>

#pragma db model version(1, 1, open)

namespace bpkg
{
  // compare_lazy_ptr
  //
  // Compare two lazy pointers via the pointed-to object ids.
  //
  struct compare_lazy_ptr
  {
    template <typename P>
    bool
    operator() (const P& x, const P& y) const
    {
      return x.object_id () < y.object_id ();
    }
  };


  // path
  //
  using optional_string = optional<string>;
  using optional_path = optional<path>;
  using optional_dir_path = optional<dir_path>;

  #pragma db map type(path) as(string)  \
    to((?).string ()) from(bpkg::path (?))

  #pragma db map type(optional_path) as(bpkg::optional_string) \
    to((?) ? (?)->string () : bpkg::optional_string ())        \
    from((?) ? bpkg::path (*(?)) : bpkg::optional_path ())

  #pragma db map type(dir_path) as(string)  \
    to((?).string ()) from(bpkg::dir_path (?))

  #pragma db map type(optional_dir_path) as(bpkg::optional_string) \
    to((?) ? (?)->string () : bpkg::optional_string ())            \
    from((?) ? bpkg::dir_path (*(?)) : bpkg::optional_dir_path ())


  // version
  //
  // Sometimes we need to split the version into two parts: the part
  // that goes into the object id (epoch, canonical upstream, revision)
  // and the original upstream. This is what the canonical_version and
  // upstream_version value types are for. Note that upstream_version
  // derives from version and uses it as storage. The idea here is this:
  // when we split the version, we often still want to have the "whole"
  // version object readily accessible and that's exactly what this
  // strange contraption is for. See available_package for an example
  // on how everything fits together.
  //
  //
  #pragma db value
  struct canonical_version
  {
    uint16_t epoch;
    string   canonical_upstream;
    uint16_t revision;
  };

  #pragma db value transient
  struct upstream_version: version
  {
    #pragma db member(upstream) virtual(string)         \
      get(this.upstream ())                             \
      set(this = bpkg::version (0, std::move (?), 0))

    upstream_version () = default;
    upstream_version (version v): version (move (v)) {}
    upstream_version&
    operator= (version v) {version& b (*this); b = v; return *this;}

    void
    init (const canonical_version& cv, const upstream_version& uv)
    {
      *this = version (cv.epoch, uv.upstream (), cv.revision);
      assert (cv.canonical_upstream == canonical_upstream ());
    }
  };

  // Use an image type to map version to the database since there
  // is no way to modify individual components directly.
  //
  #pragma db value
  struct _version
  {
    uint16_t epoch;
    string canonical_upstream;
    uint16_t revision;
    string upstream;
  };

  #pragma db map type(version) as(_version)                                \
    to(bpkg::_version{(?).epoch (),                                        \
                      (?).canonical_upstream (),                           \
                      (?).revision (),                                     \
                      (?).upstream ()})                                    \
    from(bpkg::version ((?).epoch, std::move ((?).upstream), (?).revision))


  // repository_location
  //
  #pragma db map type(repository_location) as(string)     \
    to((?).string ()) from(bpkg::repository_location (?))


  // repository
  //
  #pragma db object pointer(std::shared_ptr) session
  class repository
  {
  public:
    // We use a weak pointer for prerequisite repositories because we
    // could have cycles. No cycles in complements, thought.
    //
    using complements_type =
      std::set<lazy_shared_ptr<repository>, compare_lazy_ptr>;
    using prerequisites_type =
      std::set<lazy_weak_ptr<repository>, compare_lazy_ptr>;

    string name; // Object id (canonical name).
    repository_location location;
    complements_type complements;
    prerequisites_type prerequisites;

    // Used to detect recursive fecthing. Will probably be replaced
    // by the 'repositories' file timestamp or hashsum later.
    //
    #pragma db transient
    bool fetched = false;

  public:
    explicit
    repository (repository_location l): location (move (l))
    {
      name = location.canonical_name ();
    }

    // Database mapping.
    //
    #pragma db member(name) id

    #pragma db member(location)                                  \
      set(this.location = std::move (?);                         \
          assert (this.name == this.location.canonical_name ()))

    #pragma db member(complements) id_column("repository") \
      value_column("complement") value_not_null

    #pragma db member(prerequisites) id_column("repository") \
      value_column("prerequisite") value_not_null

  private:
    friend class odb::access;
    repository () = default;
  };

  #pragma db view object(repository) query(repository::name != "" && (?))
  struct repository_count
  {
    #pragma db column("count(*)")
    size_t result;

    operator size_t () const {return result;}
  };


  // package_location
  //
  #pragma db value
  struct package_location
  {
    using repository_type = bpkg::repository;

    lazy_shared_ptr<repository_type> repository;
    path location; // Relative to the repository.
  };


  // available_package
  //
  #pragma db value
  struct available_package_id
  {
    string name;
    canonical_version version;

    available_package_id () = default;
    available_package_id (string, const bpkg::version&);
  };

  bool
  operator< (const available_package_id&, const available_package_id&);

  #pragma db object pointer(shared_ptr) session
  class available_package
  {
  public:
    available_package_id id;
    upstream_version version;

    // List of repositories to which this package version belongs (yes,
    // in our world, it can be in multiple, unrelated repositories).
    //
    std::vector<package_location> locations; //@@ Map?

  public:
    available_package (package_manifest&& m)
        : id (move (m.name), m.version), version (move (m.version)) {}

    // Database mapping.
    //
    #pragma db member(id) id column("")

    #pragma db member(version) set(this.version.init (this.id.version, (?)))

    #pragma db member(locations) id_column("") value_column("") \
      unordered value_not_null

  private:
    friend class odb::access;
    available_package () = default;
  };

  #pragma db view object(available_package)
  struct available_package_count
  {
    #pragma db column("count(*)")
    size_t result;

    operator size_t () const {return result;}
  };

  // Only return packages that are in the specified repository or its
  // complements, recursively. While you could maybe come up with a
  // (barely comprehensible) view/query to achieve this, doing it on
  // the "client side" is definitely more straightforward.
  //
  std::vector<shared_ptr<available_package>>
  filter (const shared_ptr<repository>&, odb::result<available_package>&&);

  shared_ptr<available_package>
  filter_one (const shared_ptr<repository>&, odb::result<available_package>&&);

  // state
  //
  enum class state
  {
    broken,
    fetched,
    unpacked,
    configured
  };

  string
  to_string (state);

  state
  from_string (const string&); // May throw invalid_argument.

  inline std::ostream&
  operator<< (std::ostream& os, state s) {return os << to_string (s);}

  #pragma db map type(state) as(string) \
    to(to_string (?))                   \
    from(bpkg::from_string (?))


  // package
  //
  #pragma db object pointer(shared_ptr) session
  class package
  {
  public:
    using version_type = bpkg::version;
    using state_type = bpkg::state;

    string name; // Object id.
    version_type version;
    state_type state;

    // Path to the archive of this package, if any. If not absolute,
    // then it is relative to the configuration directory. The purge
    // flag indicates whether the archive should be removed when the
    // packaged is purged. If the archive is not present, it should
    // be false.
    //
    optional<path> archive;
    bool purge_archive;

    // Path to the source directory of this package, if any. If not
    // absolute, then it is relative to the configuration directory.
    // The purge flag indicates whether the directory should be
    // removed when the packaged is purged. If the source directory
    // is not present, it should be false.
    //
    optional<dir_path> src_root;
    bool purge_src;

    // Path to the output directory of this package, if any. It is
    // always relative to the configuration directory and currently
    // is always <name>-<version>. It is only set once the package
    // is configured and its main purse is to keep track of what
    // needs to be cleaned by the user before a broken package can
    // be purged. Note that it could be the same as out_root.
    //
    optional<dir_path> out_root;

    // Database mapping.
    //
    #pragma db member(name) id

  private:
    friend class odb::access;
    package () = default;
  };

  // Version comparison operators.
  //
  // They allow comparing a lhs object that has epoch, canonical_upstream,
  // and revision data members to the rhs version object. The idea is that
  // this works for both query members of types version and canonical_version
  // as well as for comparing canonical_version to version.
  //
  // @@ Still not sure if this is conceptually the right way to do
  //    it (should we document it as an advanced technique?).
  //
  template <typename T>
  inline auto
  operator== (const T& x, const version& y) -> decltype (x.epoch == 0)
  {
    return x.epoch == y.epoch () &&
      x.canonical_upstream == y.canonical_upstream () &&
      x.revision == y.revision ();
  }

  template <typename T>
  inline auto
  operator< (const T& x, const version& y) -> decltype (x.epoch < 0)
  {
    return x.epoch < y.epoch () ||
      (x.epoch == y.epoch () &&
       x.canonical_upstream < y.canonical_upstream ()) ||
      (x.epoch == y.epoch () &&
       x.canonical_upstream == y.canonical_upstream () &&
       x.revision < y.revision ());
  }

  template <typename T>
  inline auto
  operator> (const T& x, const version& y) -> decltype (x.epoch > 0)
  {
    return x.epoch > y.epoch () ||
      (x.epoch == y.epoch () &&
       x.canonical_upstream > y.canonical_upstream ()) ||
      (x.epoch == y.epoch () &&
       x.canonical_upstream == y.canonical_upstream () &&
       x.revision > y.revision ());
  }

  template <typename T>
  inline auto
  order_by_version_desc (const T& x) -> //decltype ("ORDER BY" + x.epoch)
                                        decltype (x.epoch == 0)
  {
    return "ORDER BY"
      + x.epoch + "DESC,"
      + x.canonical_upstream + "DESC,"
      + x.revision + "DESC";
  }
}

#include <bpkg/package.ixx>

#endif // BPKG_PACKAGE
