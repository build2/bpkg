// file      : bpkg/package -*- C++ -*-
// copyright : Copyright (c) 2014-2015 Code Synthesis Ltd
// license   : MIT; see accompanying LICENSE file

#ifndef BPKG_PACKAGE
#define BPKG_PACKAGE

#include <memory>  // shared_ptr
#include <cstdint> // uint16
#include <ostream>
#include <utility> // move()

#include <odb/core.hxx>

#include <bpkg/types>

#pragma db model version(1, 1, open)

namespace bpkg
{
  // Use an image type to map version to the database since there
  // is no way to modify individual components directly.
  //
  #pragma db value
  struct _version
  {
    std::uint16_t epoch;
    std::string upstream;
    std::uint16_t revision;
    std::string canonical_upstream;
  };
}

#include <bpkg/manifest>

namespace bpkg
{
  // path
  //
  using optional_string = optional<string>;
  using optional_path = optional<path>;
  using optional_dir_path = optional<dir_path>;

  #pragma db map type(path) as(string)  \
    to((?).string ()) from(bpkg::path (?))

  #pragma db map type(optional_path) as(bpkg::optional_string) \
    to((?) ? (?)->string () : bpkg::optional_string ())        \
    from((?) ? bpkg::path (*(?)) : bpkg::optional_path ())

  #pragma db map type(dir_path) as(string)  \
    to((?).string ()) from(bpkg::dir_path (?))

  #pragma db map type(optional_dir_path) as(bpkg::optional_string) \
    to((?) ? (?)->string () : bpkg::optional_string ())            \
    from((?) ? bpkg::dir_path (*(?)) : bpkg::optional_dir_path ())

  // version
  //
  #pragma db map type(version) as(_version)                                \
    to(bpkg::_version{(?).epoch (),                                        \
                      (?).upstream (),                                     \
                      (?).revision (),                                     \
                      (?).canonical_upstream ()})                          \
    from(bpkg::version ((?).epoch, std::move ((?).upstream), (?).revision))

  // state
  //
  enum class state
  {
    broken,
    fetched,
    unpacked,
    configured
  };

  string
  to_string (state);

  state
  from_string (const string&); // May throw invalid_argument.

  inline std::ostream&
  operator<< (std::ostream& os, state s) {return os << to_string (s);}

  #pragma db map type(state) as(string) \
    to(to_string (?))                   \
    from(bpkg::from_string (?))

  // package
  //
  #pragma db object pointer(shared_ptr)
  class package
  {
  public:
    using version_type = bpkg::version;
    using state_type = bpkg::state;

    string name;
    version_type version;
    state_type state;

    // Path to the archive of this package, if any. If not absolute,
    // then it is relative to the configuration directory. The purge
    // flag indicates whether the archive should be removed when the
    // packaged is purged. If the archive is not present, it should
    // be false.
    //
    optional<path> archive;
    bool purge_archive;

    // Path to the source directory of this package, if any. If not
    // absolute, then it is relative to the configuration directory.
    // The purge flag indicates whether the directory should be
    // removed when the packaged is purged. If the source directory
    // is not present, it should be false.
    //
    optional<dir_path> src_root;
    bool purge_src;

    // Path to the output directory of this package, if any. It is
    // always relative to the configuration directory and currently
    // is always <name>-<version>. It is only set once the package
    // is configured and its main purse is to keep track of what
    // needs to be cleaned by the user before a broken package can
    // be purged. Note that it could be the same as out_root.
    //
    optional<dir_path> out_root;

    // Database mapping.
    //
    #pragma db member(name) id

  private:
    friend class odb::access;
    package () = default;
  };
}

#endif // BPKG_PACKAGE
