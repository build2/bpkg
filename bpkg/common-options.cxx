// -*- C++ -*-
//
// This file was generated by CLI, a command line interface
// compiler for C++.
//

// Begin prologue.
//
#include <bpkg/types-parsers.hxx>
//
// End prologue.

#include <bpkg/common-options.hxx>

#include <map>
#include <set>
#include <string>
#include <vector>
#include <utility>
#include <ostream>
#include <sstream>
#include <cstring>
#include <fstream>

namespace bpkg
{
  namespace cli
  {
    // unknown_option
    //
    unknown_option::
    ~unknown_option () noexcept
    {
    }

    void unknown_option::
    print (::std::ostream& os) const
    {
      os << "unknown option '" << option ().c_str () << "'";
    }

    const char* unknown_option::
    what () const noexcept
    {
      return "unknown option";
    }

    // unknown_argument
    //
    unknown_argument::
    ~unknown_argument () noexcept
    {
    }

    void unknown_argument::
    print (::std::ostream& os) const
    {
      os << "unknown argument '" << argument ().c_str () << "'";
    }

    const char* unknown_argument::
    what () const noexcept
    {
      return "unknown argument";
    }

    // missing_value
    //
    missing_value::
    ~missing_value () noexcept
    {
    }

    void missing_value::
    print (::std::ostream& os) const
    {
      os << "missing value for option '" << option ().c_str () << "'";
    }

    const char* missing_value::
    what () const noexcept
    {
      return "missing option value";
    }

    // invalid_value
    //
    invalid_value::
    ~invalid_value () noexcept
    {
    }

    void invalid_value::
    print (::std::ostream& os) const
    {
      os << "invalid value '" << value ().c_str () << "' for option '"
         << option ().c_str () << "'";

      if (!message ().empty ())
        os << ": " << message ().c_str ();
    }

    const char* invalid_value::
    what () const noexcept
    {
      return "invalid option value";
    }

    // eos_reached
    //
    void eos_reached::
    print (::std::ostream& os) const
    {
      os << what ();
    }

    const char* eos_reached::
    what () const noexcept
    {
      return "end of argument stream reached";
    }

    // file_io_failure
    //
    file_io_failure::
    ~file_io_failure () noexcept
    {
    }

    void file_io_failure::
    print (::std::ostream& os) const
    {
      os << "unable to open file '" << file ().c_str () << "' or read failure";
    }

    const char* file_io_failure::
    what () const noexcept
    {
      return "unable to open file or read failure";
    }

    // unmatched_quote
    //
    unmatched_quote::
    ~unmatched_quote () noexcept
    {
    }

    void unmatched_quote::
    print (::std::ostream& os) const
    {
      os << "unmatched quote in argument '" << argument ().c_str () << "'";
    }

    const char* unmatched_quote::
    what () const noexcept
    {
      return "unmatched quote";
    }

    // unexpected_group
    //
    unexpected_group::
    ~unexpected_group () noexcept
    {
    }

    void unexpected_group::
    print (::std::ostream& os) const
    {
      os << "unexpected grouped argument '" << group_ << "' "
         << "for argument '" << argument_ << "'";
    }

    const char* unexpected_group::
    what () const noexcept
    {
      return "unexpected grouped argument";
    }

    // group_separator
    //
    group_separator::
    ~group_separator () noexcept
    {
    }

    void group_separator::
    print (::std::ostream& os) const
    {
      bool ex (!expected_.empty ());
      bool en (!encountered_.empty ());

      if (ex)
      {
        os << "expected group separator '" << expected_ << "'";
        if (en)
          os << " instead of '" << encountered_ << "'";
      }
      else
        os << "unexpected group separator '" << encountered_ << "'";

      if (en)
        os << ", use '\\" << encountered_ << "' to escape";
    }

    const char* group_separator::
    what () const noexcept
    {
      bool ex (!expected_.empty ());
      bool en (!encountered_.empty ());

      return en
        ? ex ? "wrong group separator"    : "unexpected group separator"
        : ex ? "expected group separator" : "";
    }

    // scanner
    //
    scanner::
    ~scanner ()
    {
    }

    // argv_scanner
    //
    bool argv_scanner::
    more ()
    {
      return i_ < argc_;
    }

    const char* argv_scanner::
    peek ()
    {
      if (i_ < argc_)
        return argv_[i_];
      else
        throw eos_reached ();
    }

    const char* argv_scanner::
    next ()
    {
      if (i_ < argc_)
      {
        const char* r (argv_[i_]);

        if (erase_)
        {
          for (int i (i_ + 1); i < argc_; ++i)
            argv_[i - 1] = argv_[i];

          --argc_;
          argv_[argc_] = 0;
        }
        else
          ++i_;

        ++start_position_;
        return r;
      }
      else
        throw eos_reached ();
    }

    void argv_scanner::
    skip ()
    {
      if (i_ < argc_)
      {
        ++i_;
        ++start_position_;
      }
      else
        throw eos_reached ();
    }

    std::size_t argv_scanner::
    position ()
    {
      return start_position_;
    }

    // vector_scanner
    //
    bool vector_scanner::
    more ()
    {
      return i_ < v_.size ();
    }

    const char* vector_scanner::
    peek ()
    {
      if (i_ < v_.size ())
        return v_[i_].c_str ();
      else
        throw eos_reached ();
    }

    const char* vector_scanner::
    next ()
    {
      if (i_ < v_.size ())
        return v_[i_++].c_str ();
      else
        throw eos_reached ();
    }

    void vector_scanner::
    skip ()
    {
      if (i_ < v_.size ())
        ++i_;
      else
        throw eos_reached ();
    }

    std::size_t vector_scanner::
    position ()
    {
      return start_position_ + i_;
    }

    // argv_file_scanner
    //
    int argv_file_scanner::zero_argc_ = 0;
    std::string argv_file_scanner::empty_string_;

    bool argv_file_scanner::
    more ()
    {
      if (!args_.empty ())
        return true;

      while (base::more ())
      {
        // See if the next argument is the file option.
        //
        const char* a (base::peek ());
        const option_info* oi = 0;
        const char* ov = 0;

        if (!skip_)
        {
          if ((oi = find (a)) != 0)
          {
            base::next ();

            if (!base::more ())
              throw missing_value (a);

            ov = base::next ();
          }
          else if (std::strncmp (a, "-", 1) == 0)
          {
            if ((ov = std::strchr (a, '=')) != 0)
            {
              std::string o (a, 0, ov - a);
              if ((oi = find (o.c_str ())) != 0)
              {
                base::next ();
                ++ov;
              }
            }
          }
        }

        if (oi != 0)
        {
          if (oi->search_func != 0)
          {
            std::string f (oi->search_func (ov, oi->arg));

            if (!f.empty ())
              load (f);
          }
          else
            load (ov);

          if (!args_.empty ())
            return true;
        }
        else
        {
          if (!skip_)
            skip_ = (std::strcmp (a, "--") == 0);

          return true;
        }
      }

      return false;
    }

    const char* argv_file_scanner::
    peek ()
    {
      if (!more ())
        throw eos_reached ();

      return args_.empty () ? base::peek () : args_.front ().value.c_str ();
    }

    const std::string& argv_file_scanner::
    peek_file ()
    {
      if (!more ())
        throw eos_reached ();

      return args_.empty () ? empty_string_ : *args_.front ().file;
    }

    std::size_t argv_file_scanner::
    peek_line ()
    {
      if (!more ())
        throw eos_reached ();

      return args_.empty () ? 0 : args_.front ().line;
    }

    const char* argv_file_scanner::
    next ()
    {
      if (!more ())
        throw eos_reached ();

      if (args_.empty ())
        return base::next ();
      else
      {
        hold_[i_ == 0 ? ++i_ : --i_].swap (args_.front ().value);
        args_.pop_front ();
        ++start_position_;
        return hold_[i_].c_str ();
      }
    }

    void argv_file_scanner::
    skip ()
    {
      if (!more ())
        throw eos_reached ();

      if (args_.empty ())
        return base::skip ();
      else
      {
        args_.pop_front ();
        ++start_position_;
      }
    }

    const argv_file_scanner::option_info* argv_file_scanner::
    find (const char* a) const
    {
      for (std::size_t i (0); i < options_count_; ++i)
        if (std::strcmp (a, options_[i].option) == 0)
          return &options_[i];

      return 0;
    }

    std::size_t argv_file_scanner::
    position ()
    {
      return start_position_;
    }

    void argv_file_scanner::
    load (const std::string& file)
    {
      using namespace std;

      ifstream is (file.c_str ());

      if (!is.is_open ())
        throw file_io_failure (file);

      files_.push_back (file);

      arg a;
      a.file = &*files_.rbegin ();

      for (a.line = 1; !is.eof (); ++a.line)
      {
        string line;
        getline (is, line);

        if (is.fail () && !is.eof ())
          throw file_io_failure (file);

        string::size_type n (line.size ());

        // Trim the line from leading and trailing whitespaces.
        //
        if (n != 0)
        {
          const char* f (line.c_str ());
          const char* l (f + n);

          const char* of (f);
          while (f < l && (*f == ' ' || *f == '\t' || *f == '\r'))
            ++f;

          --l;

          const char* ol (l);
          while (l > f && (*l == ' ' || *l == '\t' || *l == '\r'))
            --l;

          if (f != of || l != ol)
            line = f <= l ? string (f, l - f + 1) : string ();
        }

        // Ignore empty lines, those that start with #.
        //
        if (line.empty () || line[0] == '#')
          continue;

        string::size_type p (string::npos);
        if (line.compare (0, 1, "-") == 0)
        {
          p = line.find (' ');

          string::size_type q (line.find ('='));
          if (q != string::npos && q < p)
            p = q;
        }

        string s1;
        if (p != string::npos)
        {
          s1.assign (line, 0, p);

          // Skip leading whitespaces in the argument.
          //
          if (line[p] == '=')
            ++p;
          else
          {
            n = line.size ();
            for (++p; p < n; ++p)
            {
              char c (line[p]);
              if (c != ' ' && c != '\t' && c != '\r')
                break;
            }
          }
        }
        else if (!skip_)
          skip_ = (line == "--");

        string s2 (line, p != string::npos ? p : 0);

        // If the string (which is an option value or argument) is
        // wrapped in quotes, remove them.
        //
        n = s2.size ();
        char cf (s2[0]), cl (s2[n - 1]);

        if (cf == '"' || cf == '\'' || cl == '"' || cl == '\'')
        {
          if (n == 1 || cf != cl)
            throw unmatched_quote (s2);

          s2 = string (s2, 1, n - 2);
        }

        if (!s1.empty ())
        {
          // See if this is another file option.
          //
          const option_info* oi;
          if (!skip_ && (oi = find (s1.c_str ())))
          {
            if (s2.empty ())
              throw missing_value (oi->option);

            if (oi->search_func != 0)
            {
              string f (oi->search_func (s2.c_str (), oi->arg));
              if (!f.empty ())
                load (f);
            }
            else
            {
              // If the path of the file being parsed is not simple and the
              // path of the file that needs to be loaded is relative, then
              // complete the latter using the former as a base.
              //
#ifndef _WIN32
              string::size_type p (file.find_last_of ('/'));
              bool c (p != string::npos && s2[0] != '/');
#else
              string::size_type p (file.find_last_of ("/\\"));
              bool c (p != string::npos && s2[1] != ':');
#endif
              if (c)
                s2.insert (0, file, 0, p + 1);

              load (s2);
            }

            continue;
          }

          a.value = s1;
          args_.push_back (a);
        }

        a.value = s2;
        args_.push_back (a);
      }
    }

    // group_scanner
    //
    bool group_scanner::
    more ()
    {
      // We don't want to call scan_group() here since that
      // would invalidate references to previous arguments.
      // But we do need to check that the previous group was
      // handled.
      //
      if (state_ == scanned)
      {
        if (group_scan_.end () != group_.size ())
          throw unexpected_group (arg_[i_][j_], group_scan_.next ());
      }

      return j_ != 0 || scan_.more ();
    }

    const char* group_scanner::
    peek ()
    {
      if (state_ != peeked)
      {
        scan_group ();
        state_ = peeked;
      }

      // Return unescaped.
      return arg_[i_][j_ - 1].c_str ();
    }

    const char* group_scanner::
    next ()
    {
      if (state_ != peeked)
        scan_group ();
      state_ = scanned;
      // Return unescaped.
      return arg_[i_][--j_].c_str ();
    }

    void group_scanner::
    skip ()
    {
      if (state_ != peeked)
        scan_group ();
      state_ = skipped;
      --j_;
    }

    std::size_t group_scanner::
    position ()
    {
      return j_ == 0 ? scan_.position () : pos_ + (arg_[i_].size () - j_);
    }

    void group_scanner::
    scan_group ()
    {
      // If the previous argument has been scanned, then make
      // sure the group has been scanned (handled) as well.
      //
      if (state_ == scanned)
      {
        if (group_scan_.end () != group_.size ())
          throw unexpected_group (arg_[i_][j_], group_scan_.next ());
      }

      // If we still have arguments in the pack, rewind the group.
      //
      if (j_ != 0)
      {
        group_scan_.reset ();
        return;
      }

      i_ += (i_ == 0 ? 1 : -1);
      group_.clear ();
      group_scan_.reset ();
      pos_ = scan_.position ();

      // Note: using group_ won't cover empty groups and using
      // j_ won't cover single-argument packs.
      //
      bool group (false), pack (false);

      do
      {
        const char* a (scan_.next ());
        size_t i (*a == '\\' ? 1 : 0);
        separator s (sense (a + i));

        if (s == none || i != 0)
        {
          if (arg_[i_].size () != 1)
            arg_[i_].resize (1);

          arg_[i_][0] = a + (s != none ? i : 0);
          j_ = 1;
          break;
        }

        // Start of a leading group for the next argument or
        // argument pack. We will only know which once we see
        // the closing separator.
        //
        if (s != open)
          throw group_separator (a, "");

        size_t n (group_.size ());

        // Scan the group until the closing separator.
        //
        s = none;
        while (s == none && scan_.more ())
        {
          a = scan_.next ();
          i = (*a == '\\' ? 1 : 0);
          s = sense (a + i);

          if (s == none || i != 0)
          {
            group_.push_back (a + (s != none ? i : 0));
            s = none;
          }
        }

        if (s == close)
        {
          size_t m (group_.size ());

          j_ = m - n;
          if (j_ == 0)
            throw group_separator ("{", "");

          if (arg_[i_].size () != j_)
            arg_[i_].resize (j_);

          // Move from group_ to arg_. Add in reverse for ease 
          // of iteration.
          //
          for (size_t j (0); j != j_; ++j)
            arg_[i_][j] = group_[m - j - 1];
          group_.resize (n);

          pack = true;
          break;
        }
        else if (s == close_plus)
          group = true;
        else
          throw group_separator ((s != none ? a : ""), "}+");
      }
      while (scan_.more ());

      // Handle the case where we have seen the leading group
      // but there are no more arguments.
      //
      if (group && j_ == 0)
        throw group_separator ("{", "");

      // Handle trailing groups, if any.
      //
      while (scan_.more ())
      {
        const char* a (scan_.peek ());
        size_t i (*a == '\\' ? 1 : 0);
        separator s (sense (a + i));

        // Next argument, argument pack, or leading group.
        //
        if (s == none || s == open || i != 0)
          break;

        if (s != open_plus)
          throw group_separator (a, "");

        group = true;

        // Scan the group until the closing separator.
        //
        scan_.next ();
        s = none;
        while (s == none && scan_.more ())
        {
          a = scan_.next ();
          i = (*a == '\\' ? 1 : 0);
          s = sense (a + i);

          if (s == none || i != 0)
          {
            group_.push_back (a + (s != none ? i : 0));
            s = none;
          }
        }

        if (s != close)
          throw group_separator ((s != none ? a : ""), "}");
      }

      // Handle the case where we have seen the argument pack
      // without leading or trailing group.
      //
      if (pack && !group)
        throw group_separator ("{", "");
    }

    template <typename X>
    struct parser
    {
      static void
      parse (X& x, bool& xs, scanner& s)
      {
        using namespace std;

        const char* o (s.next ());
        if (s.more ())
        {
          string v (s.next ());
          istringstream is (v);
          if (!(is >> x && is.peek () == istringstream::traits_type::eof ()))
            throw invalid_value (o, v);
        }
        else
          throw missing_value (o);

        xs = true;
      }

      static void
      merge (X& b, const X& a)
      {
        b = a;
      }
    };

    template <>
    struct parser<bool>
    {
      static void
      parse (bool& x, bool& xs, scanner& s)
      {
        const char* o (s.next ());

        if (s.more ())
        {
          const char* v (s.next ());

          if (std::strcmp (v, "1")    == 0 ||
              std::strcmp (v, "true") == 0 ||
              std::strcmp (v, "TRUE") == 0 ||
              std::strcmp (v, "True") == 0)
            x = true;
          else if (std::strcmp (v, "0")     == 0 ||
                   std::strcmp (v, "false") == 0 ||
                   std::strcmp (v, "FALSE") == 0 ||
                   std::strcmp (v, "False") == 0)
            x = false;
          else
            throw invalid_value (o, v);
        }
        else
          throw missing_value (o);

        xs = true;
      }

      static void
      merge (bool& b, const bool&)
      {
        b = true;
      }
    };

    template <>
    struct parser<std::string>
    {
      static void
      parse (std::string& x, bool& xs, scanner& s)
      {
        const char* o (s.next ());

        if (s.more ())
          x = s.next ();
        else
          throw missing_value (o);

        xs = true;
      }

      static void
      merge (std::string& b, const std::string& a)
      {
        b = a;
      }
    };

    template <typename X>
    struct parser<std::pair<X, std::size_t> >
    {
      static void
      parse (std::pair<X, std::size_t>& x, bool& xs, scanner& s)
      {
        x.second = s.position ();
        parser<X>::parse (x.first, xs, s);
      }

      static void
      merge (std::pair<X, std::size_t>& b, const std::pair<X, std::size_t>& a)
      {
        b = a;
      }
    };

    template <typename X>
    struct parser<std::vector<X> >
    {
      static void
      parse (std::vector<X>& c, bool& xs, scanner& s)
      {
        X x;
        bool dummy;
        parser<X>::parse (x, dummy, s);
        c.push_back (x);
        xs = true;
      }

      static void
      merge (std::vector<X>& b, const std::vector<X>& a)
      {
        b.insert (b.end (), a.begin (), a.end ());
      }
    };

    template <typename X, typename C>
    struct parser<std::set<X, C> >
    {
      static void
      parse (std::set<X, C>& c, bool& xs, scanner& s)
      {
        X x;
        bool dummy;
        parser<X>::parse (x, dummy, s);
        c.insert (x);
        xs = true;
      }

      static void
      merge (std::set<X, C>& b, const std::set<X, C>& a)
      {
        b.insert (a.begin (), a.end ());
      }
    };

    template <typename K, typename V, typename C>
    struct parser<std::map<K, V, C> >
    {
      static void
      parse (std::map<K, V, C>& m, bool& xs, scanner& s)
      {
        const char* o (s.next ());

        if (s.more ())
        {
          std::size_t pos (s.position ());
          std::string ov (s.next ());
          std::string::size_type p = ov.find ('=');

          K k = K ();
          V v = V ();
          std::string kstr (ov, 0, p);
          std::string vstr (ov, (p != std::string::npos ? p + 1 : ov.size ()));

          int ac (2);
          char* av[] =
          {
            const_cast<char*> (o),
            0
          };

          bool dummy;
          if (!kstr.empty ())
          {
            av[1] = const_cast<char*> (kstr.c_str ());
            argv_scanner s (0, ac, av, false, pos);
            parser<K>::parse (k, dummy, s);
          }

          if (!vstr.empty ())
          {
            av[1] = const_cast<char*> (vstr.c_str ());
            argv_scanner s (0, ac, av, false, pos);
            parser<V>::parse (v, dummy, s);
          }

          m[k] = v;
        }
        else
          throw missing_value (o);

        xs = true;
      }

      static void
      merge (std::map<K, V, C>& b, const std::map<K, V, C>& a)
      {
        for (typename std::map<K, V, C>::const_iterator i (a.begin ()); 
             i != a.end (); 
             ++i)
          b[i->first] = i->second;
      }
    };

    template <typename K, typename V, typename C>
    struct parser<std::multimap<K, V, C> >
    {
      static void
      parse (std::multimap<K, V, C>& m, bool& xs, scanner& s)
      {
        const char* o (s.next ());

        if (s.more ())
        {
          std::size_t pos (s.position ());
          std::string ov (s.next ());
          std::string::size_type p = ov.find ('=');

          K k = K ();
          V v = V ();
          std::string kstr (ov, 0, p);
          std::string vstr (ov, (p != std::string::npos ? p + 1 : ov.size ()));

          int ac (2);
          char* av[] =
          {
            const_cast<char*> (o),
            0
          };

          bool dummy;
          if (!kstr.empty ())
          {
            av[1] = const_cast<char*> (kstr.c_str ());
            argv_scanner s (0, ac, av, false, pos);
            parser<K>::parse (k, dummy, s);
          }

          if (!vstr.empty ())
          {
            av[1] = const_cast<char*> (vstr.c_str ());
            argv_scanner s (0, ac, av, false, pos);
            parser<V>::parse (v, dummy, s);
          }

          m.insert (typename std::multimap<K, V, C>::value_type (k, v));
        }
        else
          throw missing_value (o);

        xs = true;
      }

      static void
      merge (std::multimap<K, V, C>& b, const std::multimap<K, V, C>& a)
      {
        for (typename std::multimap<K, V, C>::const_iterator i (a.begin ()); 
             i != a.end (); 
             ++i)
          b.insert (typename std::multimap<K, V, C>::value_type (i->first,
                                                                 i->second));
      }
    };

    template <typename X, typename T, T X::*M>
    void
    thunk (X& x, scanner& s)
    {
      parser<T>::parse (x.*M, s);
    }

    template <typename X, bool X::*M>
    void
    thunk (X& x, scanner& s)
    {
      s.next ();
      x.*M = true;
    }

    template <typename X, typename T, T X::*M, bool X::*S>
    void
    thunk (X& x, scanner& s)
    {
      parser<T>::parse (x.*M, x.*S, s);
    }
  }
}

#include <map>

namespace bpkg
{
  // common_options
  //

  common_options::
  common_options ()
  : v_ (),
    V_ (),
    quiet_ (),
    verbose_ (1),
    verbose_specified_ (false),
    stdout_format_ (bpkg::stdout_format::lines),
    stdout_format_specified_ (false),
    jobs_ (),
    jobs_specified_ (false),
    no_result_ (),
    structured_result_ (),
    structured_result_specified_ (false),
    progress_ (),
    no_progress_ (),
    diag_color_ (),
    no_diag_color_ (),
    build_ (),
    build_specified_ (false),
    build_option_ (),
    build_option_specified_ (false),
    fetch_ (),
    fetch_specified_ (false),
    fetch_option_ (),
    fetch_option_specified_ (false),
    curl_ (),
    curl_specified_ (false),
    curl_option_ (),
    curl_option_specified_ (false),
    fetch_timeout_ (),
    fetch_timeout_specified_ (false),
    offline_ (),
    no_fetch_cache_ (),
    fetch_cache_ (),
    fetch_cache_specified_ (false),
    fetch_cache_path_ (),
    fetch_cache_path_specified_ (false),
    fetch_cache_session_ (),
    fetch_cache_session_specified_ (false),
    sqlite_synchronous_ (bpkg::sqlite_synchronous::normal),
    sqlite_synchronous_specified_ (false),
    pkg_proxy_ (),
    pkg_proxy_specified_ (false),
    git_ ("git"),
    git_specified_ (false),
    git_option_ (),
    git_option_specified_ (false),
    sha256_ (),
    sha256_specified_ (false),
    sha256_option_ (),
    sha256_option_specified_ (false),
    tar_ (),
    tar_specified_ (false),
    tar_option_ (),
    tar_option_specified_ (false),
    openssl_ ("openssl"),
    openssl_specified_ (false),
    openssl_option_ (),
    openssl_option_specified_ (false),
    auth_ (bpkg::auth::remote),
    auth_specified_ (false),
    trust_ (),
    trust_specified_ (false),
    trust_yes_ (),
    trust_no_ (),
    git_capabilities_ (),
    git_capabilities_specified_ (false),
    pager_ (),
    pager_specified_ (false),
    pager_option_ (),
    pager_option_specified_ (false),
    options_file_ (),
    options_file_specified_ (false),
    default_options_ (),
    default_options_specified_ (false),
    no_default_options_ (),
    keep_tmp_ ()
  {
  }

  void common_options::
  merge (const common_options& a)
  {
    CLI_POTENTIALLY_UNUSED (a);

    if (a.v_)
    {
      ::bpkg::cli::parser< bool>::merge (
        this->v_, a.v_);
    }

    if (a.V_)
    {
      ::bpkg::cli::parser< bool>::merge (
        this->V_, a.V_);
    }

    if (a.quiet_)
    {
      ::bpkg::cli::parser< bool>::merge (
        this->quiet_, a.quiet_);
    }

    if (a.verbose_specified_)
    {
      ::bpkg::cli::parser< uint16_t>::merge (
        this->verbose_, a.verbose_);
      this->verbose_specified_ = true;
    }

    if (a.stdout_format_specified_)
    {
      ::bpkg::cli::parser< bpkg::stdout_format>::merge (
        this->stdout_format_, a.stdout_format_);
      this->stdout_format_specified_ = true;
    }

    if (a.jobs_specified_)
    {
      ::bpkg::cli::parser< size_t>::merge (
        this->jobs_, a.jobs_);
      this->jobs_specified_ = true;
    }

    if (a.no_result_)
    {
      ::bpkg::cli::parser< bool>::merge (
        this->no_result_, a.no_result_);
    }

    if (a.structured_result_specified_)
    {
      ::bpkg::cli::parser< string>::merge (
        this->structured_result_, a.structured_result_);
      this->structured_result_specified_ = true;
    }

    if (a.progress_)
    {
      ::bpkg::cli::parser< bool>::merge (
        this->progress_, a.progress_);
    }

    if (a.no_progress_)
    {
      ::bpkg::cli::parser< bool>::merge (
        this->no_progress_, a.no_progress_);
    }

    if (a.diag_color_)
    {
      ::bpkg::cli::parser< bool>::merge (
        this->diag_color_, a.diag_color_);
    }

    if (a.no_diag_color_)
    {
      ::bpkg::cli::parser< bool>::merge (
        this->no_diag_color_, a.no_diag_color_);
    }

    if (a.build_specified_)
    {
      ::bpkg::cli::parser< path>::merge (
        this->build_, a.build_);
      this->build_specified_ = true;
    }

    if (a.build_option_specified_)
    {
      ::bpkg::cli::parser< strings>::merge (
        this->build_option_, a.build_option_);
      this->build_option_specified_ = true;
    }

    if (a.fetch_specified_)
    {
      ::bpkg::cli::parser< path>::merge (
        this->fetch_, a.fetch_);
      this->fetch_specified_ = true;
    }

    if (a.fetch_option_specified_)
    {
      ::bpkg::cli::parser< strings>::merge (
        this->fetch_option_, a.fetch_option_);
      this->fetch_option_specified_ = true;
    }

    if (a.curl_specified_)
    {
      ::bpkg::cli::parser< path>::merge (
        this->curl_, a.curl_);
      this->curl_specified_ = true;
    }

    if (a.curl_option_specified_)
    {
      ::bpkg::cli::parser< strings>::merge (
        this->curl_option_, a.curl_option_);
      this->curl_option_specified_ = true;
    }

    if (a.fetch_timeout_specified_)
    {
      ::bpkg::cli::parser< size_t>::merge (
        this->fetch_timeout_, a.fetch_timeout_);
      this->fetch_timeout_specified_ = true;
    }

    if (a.offline_)
    {
      ::bpkg::cli::parser< bool>::merge (
        this->offline_, a.offline_);
    }

    if (a.no_fetch_cache_)
    {
      ::bpkg::cli::parser< bool>::merge (
        this->no_fetch_cache_, a.no_fetch_cache_);
    }

    if (a.fetch_cache_specified_)
    {
      ::bpkg::cli::parser< string>::merge (
        this->fetch_cache_, a.fetch_cache_);
      this->fetch_cache_specified_ = true;
    }

    if (a.fetch_cache_path_specified_)
    {
      ::bpkg::cli::parser< dir_path>::merge (
        this->fetch_cache_path_, a.fetch_cache_path_);
      this->fetch_cache_path_specified_ = true;
    }

    if (a.fetch_cache_session_specified_)
    {
      ::bpkg::cli::parser< string>::merge (
        this->fetch_cache_session_, a.fetch_cache_session_);
      this->fetch_cache_session_specified_ = true;
    }

    if (a.sqlite_synchronous_specified_)
    {
      ::bpkg::cli::parser< bpkg::sqlite_synchronous>::merge (
        this->sqlite_synchronous_, a.sqlite_synchronous_);
      this->sqlite_synchronous_specified_ = true;
    }

    if (a.pkg_proxy_specified_)
    {
      ::bpkg::cli::parser< butl::url>::merge (
        this->pkg_proxy_, a.pkg_proxy_);
      this->pkg_proxy_specified_ = true;
    }

    if (a.git_specified_)
    {
      ::bpkg::cli::parser< path>::merge (
        this->git_, a.git_);
      this->git_specified_ = true;
    }

    if (a.git_option_specified_)
    {
      ::bpkg::cli::parser< strings>::merge (
        this->git_option_, a.git_option_);
      this->git_option_specified_ = true;
    }

    if (a.sha256_specified_)
    {
      ::bpkg::cli::parser< path>::merge (
        this->sha256_, a.sha256_);
      this->sha256_specified_ = true;
    }

    if (a.sha256_option_specified_)
    {
      ::bpkg::cli::parser< strings>::merge (
        this->sha256_option_, a.sha256_option_);
      this->sha256_option_specified_ = true;
    }

    if (a.tar_specified_)
    {
      ::bpkg::cli::parser< path>::merge (
        this->tar_, a.tar_);
      this->tar_specified_ = true;
    }

    if (a.tar_option_specified_)
    {
      ::bpkg::cli::parser< strings>::merge (
        this->tar_option_, a.tar_option_);
      this->tar_option_specified_ = true;
    }

    if (a.openssl_specified_)
    {
      ::bpkg::cli::parser< qualified_option<openssl_commands, path>>::merge (
        this->openssl_, a.openssl_);
      this->openssl_specified_ = true;
    }

    if (a.openssl_option_specified_)
    {
      ::bpkg::cli::parser< qualified_option<openssl_commands, strings>>::merge (
        this->openssl_option_, a.openssl_option_);
      this->openssl_option_specified_ = true;
    }

    if (a.auth_specified_)
    {
      ::bpkg::cli::parser< bpkg::auth>::merge (
        this->auth_, a.auth_);
      this->auth_specified_ = true;
    }

    if (a.trust_specified_)
    {
      ::bpkg::cli::parser< std::set<string, icase_compare_string>>::merge (
        this->trust_, a.trust_);
      this->trust_specified_ = true;
    }

    if (a.trust_yes_)
    {
      ::bpkg::cli::parser< bool>::merge (
        this->trust_yes_, a.trust_yes_);
    }

    if (a.trust_no_)
    {
      ::bpkg::cli::parser< bool>::merge (
        this->trust_no_, a.trust_no_);
    }

    if (a.git_capabilities_specified_)
    {
      ::bpkg::cli::parser< git_capabilities_map>::merge (
        this->git_capabilities_, a.git_capabilities_);
      this->git_capabilities_specified_ = true;
    }

    if (a.pager_specified_)
    {
      ::bpkg::cli::parser< string>::merge (
        this->pager_, a.pager_);
      this->pager_specified_ = true;
    }

    if (a.pager_option_specified_)
    {
      ::bpkg::cli::parser< strings>::merge (
        this->pager_option_, a.pager_option_);
      this->pager_option_specified_ = true;
    }

    if (a.options_file_specified_)
    {
      ::bpkg::cli::parser< string>::merge (
        this->options_file_, a.options_file_);
      this->options_file_specified_ = true;
    }

    if (a.default_options_specified_)
    {
      ::bpkg::cli::parser< dir_path>::merge (
        this->default_options_, a.default_options_);
      this->default_options_specified_ = true;
    }

    if (a.no_default_options_)
    {
      ::bpkg::cli::parser< bool>::merge (
        this->no_default_options_, a.no_default_options_);
    }

    if (a.keep_tmp_)
    {
      ::bpkg::cli::parser< bool>::merge (
        this->keep_tmp_, a.keep_tmp_);
    }
  }

  ::bpkg::cli::usage_para common_options::
  print_usage (::std::ostream& os, ::bpkg::cli::usage_para p)
  {
    CLI_POTENTIALLY_UNUSED (os);

    if (p != ::bpkg::cli::usage_para::none)
      os << ::std::endl;

    os << "\033[1mCOMMON OPTIONS\033[0m" << ::std::endl;

    os << std::endl
       << "The common options are summarized below with a more detailed description" << ::std::endl
       << "available in \033[1mbpkg-common-options(1)\033[0m." << ::std::endl;

    os << std::endl
       << "\033[1m-v\033[0m                        Print essential underlying commands being executed." << ::std::endl;

    os << "\033[1m-V\033[0m                        Print all underlying commands being executed." << ::std::endl;

    os << "\033[1m--quiet\033[0m|\033[1m-q\033[0m                Run quietly, only printing error messages." << ::std::endl;

    os << "\033[1m--verbose\033[0m \033[4mlevel\033[0m           Set the diagnostics verbosity to \033[4mlevel\033[0m between 0 and" << ::std::endl
       << "                          6." << ::std::endl;

    os << "\033[1m--stdout-format\033[0m \033[4mformat\033[0m    Representation format to use for printing to \033[1mstdout\033[0m." << ::std::endl;

    os << "\033[1m--jobs\033[0m|\033[1m-j\033[0m \033[4mnum\033[0m             Number of jobs to perform in parallel." << ::std::endl;

    os << "\033[1m--no-result\033[0m               Don't print informational messages about the outcome" << ::std::endl
       << "                          of performing a command or some of its parts." << ::std::endl;

    os << "\033[1m--structured-result\033[0m \033[4mfmt\033[0m   Write the result of performing a command in a" << ::std::endl
       << "                          structured form." << ::std::endl;

    os << "\033[1m--progress\033[0m                Display progress indicators for long-lasting" << ::std::endl
       << "                          operations, such as network transfers, building, etc." << ::std::endl;

    os << "\033[1m--no-progress\033[0m             Suppress progress indicators for long-lasting" << ::std::endl
       << "                          operations, such as network transfers, building, etc." << ::std::endl;

    os << "\033[1m--diag-color\033[0m              Use color in diagnostics." << ::std::endl;

    os << "\033[1m--no-diag-color\033[0m           Don't use color in diagnostics." << ::std::endl;

    os << "\033[1m--build\033[0m \033[4mpath\033[0m              The build program to be used to build packages." << ::std::endl;

    os << "\033[1m--build-option\033[0m \033[4mopt\033[0m        Additional option to be passed to the build program." << ::std::endl;

    os << "\033[1m--fetch\033[0m \033[4mpath\033[0m              The fetch program to be used to download resources" << ::std::endl
       << "                          (packages, repository metadata, etc)." << ::std::endl;

    os << "\033[1m--fetch-option\033[0m \033[4mopt\033[0m        Additional option to be passed to the fetch program." << ::std::endl;

    os << "\033[1m--fetch-timeout\033[0m \033[4msec\033[0m       The fetch and fetch-like (for example, \033[1mgit\033[0m) program" << ::std::endl
       << "                          timeout." << ::std::endl;

    os << "\033[1m--offline\033[0m                 Do not attempt to download resources (packages," << ::std::endl
       << "                          repository metadata, etc), instead taking them from" << ::std::endl
       << "                          the local fetch cache if available and failing" << ::std::endl
       << "                          otherwise." << ::std::endl;

    os << "\033[1m--no-fetch-cache\033[0m          Disable local caching of downloaded resources" << ::std::endl
       << "                          (packages, repository metadata, etc)." << ::std::endl;

    os << "\033[1m--fetch-cache\033[0m \033[4mmode\033[0m        Comma-separated list of local fetch cache modes." << ::std::endl;

    os << "\033[1m--fetch-cache-path\033[0m \033[4mdir\033[0m    The directory of the local fetch cache." << ::std::endl;

    os << "\033[1m--fetch-cache-session\033[0m \033[4mid\033[0m  The local fetch cache session." << ::std::endl;

    os << "\033[1m--sqlite-synchronous\033[0m \033[4mmode\033[0m Synchronous mode for fetch cache and configuration" << ::std::endl
       << "                          databases." << ::std::endl;

    os << "\033[1m--pkg-proxy\033[0m \033[4murl\033[0m           HTTP proxy server to use when fetching package" << ::std::endl
       << "                          manifests and archives from remote \033[1mpkg\033[0m repositories." << ::std::endl;

    os << "\033[1m--git\033[0m \033[4mpath\033[0m                The git program to be used to fetch git repositories." << ::std::endl;

    os << "\033[1m--git-option\033[0m \033[4mopt\033[0m          Additional common option to be passed to the git" << ::std::endl
       << "                          program." << ::std::endl;

    os << "\033[1m--sha256\033[0m \033[4mpath\033[0m             The sha256 program to be used to calculate SHA256" << ::std::endl
       << "                          sums." << ::std::endl;

    os << "\033[1m--sha256-option\033[0m \033[4mopt\033[0m       Additional option to be passed to the sha256 program." << ::std::endl;

    os << "\033[1m--tar\033[0m \033[4mpath\033[0m                The tar program to be used to extract package" << ::std::endl
       << "                          archives." << ::std::endl;

    os << "\033[1m--tar-option\033[0m \033[4mopt\033[0m          Additional option to be passed to the tar program." << ::std::endl;

    os << "\033[1m--openssl\033[0m \033[4mpath\033[0m            The openssl program to be used for crypto operations." << ::std::endl;

    os << "\033[1m--openssl-option\033[0m \033[4mopt\033[0m      Additional option to be passed to the openssl" << ::std::endl
       << "                          program." << ::std::endl;

    os << "\033[1m--auth\033[0m \033[4mtype\033[0m               Types of repositories to authenticate." << ::std::endl;

    os << "\033[1m--trust\033[0m \033[4mfingerprint\033[0m       Trust repository certificate with a SHA256" << ::std::endl
       << "                          \033[4mfingerprint\033[0m." << ::std::endl;

    os << "\033[1m--trust-yes\033[0m               Assume the answer to all authentication prompts is" << ::std::endl
       << "                          \033[1myes\033[0m." << ::std::endl;

    os << "\033[1m--trust-no\033[0m                Assume the answer to all authentication prompts is" << ::std::endl
       << "                          \033[1mno\033[0m." << ::std::endl;

    os << "\033[1m--git-capabilities\033[0m \033[4mup\033[0m=\033[4mpc\033[0m  Protocol capabilities (\033[4mpc\033[0m) for a \033[1mgit\033[0m repository URL" << ::std::endl
       << "                          prefix (\033[4mup\033[0m)." << ::std::endl;

    os << "\033[1m--pager\033[0m \033[4mpath\033[0m              The pager program to be used to show long text." << ::std::endl;

    os << "\033[1m--pager-option\033[0m \033[4mopt\033[0m        Additional option to be passed to the pager program." << ::std::endl;

    os << "\033[1m--options-file\033[0m \033[4mfile\033[0m       Read additional options from \033[4mfile\033[0m." << ::std::endl;

    os << "\033[1m--default-options\033[0m \033[4mdir\033[0m     The directory to load additional default options" << ::std::endl
       << "                          files from." << ::std::endl;

    os << "\033[1m--no-default-options\033[0m      Don't load default options files." << ::std::endl;

    os << "\033[1m--keep-tmp\033[0m                Don't remove the \033[1mbpkg\033[0m's temporary directory at the" << ::std::endl
       << "                          end of the command execution and print its path at" << ::std::endl
       << "                          the verbosity level 2 or higher." << ::std::endl;

    p = ::bpkg::cli::usage_para::option;

    return p;
  }

  ::bpkg::cli::usage_para common_options::
  print_long_usage (::std::ostream& os, ::bpkg::cli::usage_para p)
  {
    CLI_POTENTIALLY_UNUSED (os);

    if (p != ::bpkg::cli::usage_para::none)
      os << ::std::endl;

    os << "\033[1mCOMMON OPTIONS\033[0m" << ::std::endl;

    os << std::endl
       << "\033[1m-v\033[0m                        Print essential underlying commands being executed." << ::std::endl
       << "                          This is equivalent to \033[1m--verbose 2\033[0m." << ::std::endl;

    os << std::endl
       << "\033[1m-V\033[0m                        Print all underlying commands being executed. This is" << ::std::endl
       << "                          equivalent to \033[1m--verbose 3\033[0m." << ::std::endl;

    os << std::endl
       << "\033[1m--quiet\033[0m|\033[1m-q\033[0m                Run quietly, only printing error messages. This is" << ::std::endl
       << "                          equivalent to \033[1m--verbose 0\033[0m." << ::std::endl;

    os << std::endl
       << "\033[1m--verbose\033[0m \033[4mlevel\033[0m           Set the diagnostics verbosity to \033[4mlevel\033[0m between 0 and" << ::std::endl
       << "                          6. Level 0 disables any non-error messages while" << ::std::endl
       << "                          level 6 produces lots of information, with level 1" << ::std::endl
       << "                          being the default. The following additional types of" << ::std::endl
       << "                          diagnostics are produced at each level:" << ::std::endl
       << ::std::endl
       << "                          1. High-level information messages." << ::std::endl
       << "                          2. Essential underlying commands being executed." << ::std::endl
       << "                          3. All underlying commands being executed." << ::std::endl
       << "                          4. Information that could be helpful to the user." << ::std::endl
       << "                          5. Information that could be helpful to the" << ::std::endl
       << "                          developer." << ::std::endl
       << "                          6. Even more detailed information." << ::std::endl;

    os << std::endl
       << "\033[1m--stdout-format\033[0m \033[4mformat\033[0m    Representation format to use for printing to \033[1mstdout\033[0m." << ::std::endl
       << "                          Valid values for this option are \033[1mlines\033[0m (default) and" << ::std::endl
       << "                          \033[1mjson\033[0m. See the JSON OUTPUT section below for details" << ::std::endl
       << "                          on the \033[1mjson\033[0m format." << ::std::endl;

    os << std::endl
       << "\033[1m--jobs\033[0m|\033[1m-j\033[0m \033[4mnum\033[0m             Number of jobs to perform in parallel. If this option" << ::std::endl
       << "                          is not specified or specified with the 0\033[0m value, then" << ::std::endl
       << "                          the number of available hardware threads is used." << ::std::endl
       << "                          This option is also propagated when performing build" << ::std::endl
       << "                          system operations such as \033[1mupdate\033[0m, \033[1mtest\033[0m, etc." << ::std::endl;

    os << std::endl
       << "\033[1m--no-result\033[0m               Don't print informational messages about the outcome" << ::std::endl
       << "                          of performing a command or some of its parts. Note" << ::std::endl
       << "                          that if this option is specified, then for certain" << ::std::endl
       << "                          long-running command parts progress is displayed" << ::std::endl
       << "                          instead, unless suppressed with \033[1m--no-progress\033[0m." << ::std::endl;

    os << std::endl
       << "\033[1m--structured-result\033[0m \033[4mfmt\033[0m   Write the result of performing a command in a" << ::std::endl
       << "                          structured form. In this mode, instead of printing to" << ::std::endl
       << "                          \033[1mstderr\033[0m informational messages about the outcome of" << ::std::endl
       << "                          performing a command or some of its parts, \033[1mbpkg\033[0m" << ::std::endl
       << "                          writes to \033[1mstdout\033[0m a machine-readable result" << ::std::endl
       << "                          description in the specified format. Not all commands" << ::std::endl
       << "                          support producing structured result and valid \033[4mfmt\033[0m" << ::std::endl
       << "                          values are command-specific. Consult the command" << ::std::endl
       << "                          documentation for details." << ::std::endl;

    os << std::endl
       << "\033[1m--progress\033[0m                Display progress indicators for long-lasting" << ::std::endl
       << "                          operations, such as network transfers, building, etc." << ::std::endl
       << "                          If printing to a terminal the progress is displayed" << ::std::endl
       << "                          by default for low verbosity levels. Use" << ::std::endl
       << "                          \033[1m--no-progress\033[0m to suppress." << ::std::endl;

    os << std::endl
       << "\033[1m--no-progress\033[0m             Suppress progress indicators for long-lasting" << ::std::endl
       << "                          operations, such as network transfers, building, etc." << ::std::endl;

    os << std::endl
       << "\033[1m--diag-color\033[0m              Use color in diagnostics. If printing to a terminal" << ::std::endl
       << "                          the color is used by default provided the terminal is" << ::std::endl
       << "                          not dumb. Use \033[1m--no-diag-color\033[0m to suppress." << ::std::endl;

    os << std::endl
       << "\033[1m--no-diag-color\033[0m           Don't use color in diagnostics." << ::std::endl;

    os << std::endl
       << "\033[1m--build\033[0m \033[4mpath\033[0m              The build program to be used to build packages. This" << ::std::endl
       << "                          should be the path to the build2 \033[1mb\033[0m executable. You" << ::std::endl
       << "                          can also specify additional options that should be" << ::std::endl
       << "                          passed to the build program with \033[1m--build-option\033[0m." << ::std::endl
       << ::std::endl
       << "                          If the build program is not explicitly specified," << ::std::endl
       << "                          then \033[1mbpkg\033[0m will by default use \033[1mb\033[0m plus an executable" << ::std::endl
       << "                          suffix if one was specified when building \033[1mbpkg\033[0m. So," << ::std::endl
       << "                          for example, if \033[1mbpkg\033[0m name was set to \033[1mbpkg-1.0\033[0m, then" << ::std::endl
       << "                          it will look for \033[1mb-1.0\033[0m." << ::std::endl;

    os << std::endl
       << "\033[1m--build-option\033[0m \033[4mopt\033[0m        Additional option to be passed to the build program." << ::std::endl
       << "                          See \033[1m--build\033[0m for more information on the build" << ::std::endl
       << "                          program. Repeat this option to specify multiple build" << ::std::endl
       << "                          options." << ::std::endl;

    os << std::endl
       << "\033[1m--fetch\033[0m \033[4mpath\033[0m              The fetch program to be used to download resources" << ::std::endl
       << "                          (packages, repository metadata, etc). Currently," << ::std::endl
       << "                          \033[1mbpkg\033[0m recognizes \033[1mcurl\033[0m, \033[1mwget\033[0m, and \033[1mfetch\033[0m. Note that the" << ::std::endl
       << "                          last component of \033[4mpath\033[0m must contain one of these" << ::std::endl
       << "                          names as a substring in order for \033[1mbpkg\033[0m to recognize" << ::std::endl
       << "                          which program is being used. You can also specify" << ::std::endl
       << "                          additional options that should be passed to the fetch" << ::std::endl
       << "                          program with \033[1m--fetch-option\033[0m." << ::std::endl
       << ::std::endl
       << "                          If the fetch program is not specified, then \033[1mbpkg\033[0m will" << ::std::endl
       << "                          try to discover if one of the above programs is" << ::std::endl
       << "                          available and use that. Currently, \033[1mbpkg\033[0m has the" << ::std::endl
       << "                          following preference order: \033[1mcurl\033[0m, \033[1mwget\033[0m, and \033[1mfetch\033[0m." << ::std::endl;

    os << std::endl
       << "\033[1m--fetch-option\033[0m \033[4mopt\033[0m        Additional option to be passed to the fetch program." << ::std::endl
       << "                          See \033[1m--fetch\033[0m for more information on the fetch" << ::std::endl
       << "                          program. Repeat this option to specify multiple fetch" << ::std::endl
       << "                          options." << ::std::endl;

    os << std::endl
       << "\033[1m--fetch-timeout\033[0m \033[4msec\033[0m       The fetch and fetch-like (for example, \033[1mgit\033[0m) program" << ::std::endl
       << "                          timeout. While the exact semantics of the value" << ::std::endl
       << "                          depends on the program used, at a minimum it" << ::std::endl
       << "                          specifies in seconds the maximum time that can be" << ::std::endl
       << "                          spent without any network activity." << ::std::endl
       << ::std::endl
       << "                          Specifically, it is translated to the \033[1m--max-time\033[0m" << ::std::endl
       << "                          option for \033[1mcurl\033[0m and to the \033[1m--timeout\033[0m option for \033[1mwget\033[0m" << ::std::endl
       << "                          and \033[1mfetch\033[0m. For \033[1mgit\033[0m over HTTP/HTTPS this semantics is" << ::std::endl
       << "                          achieved using the \033[1mhttp.lowSpeedLimit\033[0m=\033[4m1\033[0m" << ::std::endl
       << "                          \033[1mhttp.lowSpeedTime\033[0m=\033[4msec\033[0m configuration values (the" << ::std::endl
       << "                          \033[1mgit://\033[0m and \033[1mssh://\033[0m protocols currently do not support" << ::std::endl
       << "                          timeouts)." << ::std::endl
       << ::std::endl
       << "                          See \033[1m--fetch\033[0m and \033[1m--git\033[0m for more information on the" << ::std::endl
       << "                          fetch programs." << ::std::endl;

    os << std::endl
       << "\033[1m--offline\033[0m                 Do not attempt to download resources (packages," << ::std::endl
       << "                          repository metadata, etc), instead taking them from" << ::std::endl
       << "                          the local fetch cache if available and failing" << ::std::endl
       << "                          otherwise. Note that no up-to-date checks of cached" << ::std::endl
       << "                          repository metadata are performed when offline. This" << ::std::endl
       << "                          mode can also be enabled by setting the" << ::std::endl
       << "                          \033[1mBPKG_FETCH_CACHE\033[0m environment variable, see the" << ::std::endl
       << "                          \033[1m--fetch-cache\033[0m option description for details." << ::std::endl;

    os << std::endl
       << "\033[1m--no-fetch-cache\033[0m          Disable local caching of downloaded resources" << ::std::endl
       << "                          (packages, repository metadata, etc). By default" << ::std::endl
       << "                          these are cached in a persistent local cache. For the" << ::std::endl
       << "                          location of the cache, see the \033[1m--fetch-cache-path\033[0m" << ::std::endl
       << "                          option. The local cache can also be disabled by" << ::std::endl
       << "                          setting the \033[1mBPKG_FETCH_CACHE\033[0m environment variable to" << ::std::endl
       << "                          \033[1m0\033[0m or \033[1mfalse\033[0m." << ::std::endl
       << ::std::endl
       << "                          Note that if this option or environment variable is" << ::std::endl
       << "                          specified during the configuration creation" << ::std::endl
       << "                          (\033[1mcfg-create(1)\033[0m), its value is saved in the" << ::std::endl
       << "                          configuration and used as the default in the" << ::std::endl
       << "                          subsequent \033[1mbpkg\033[0m commands involving this" << ::std::endl
       << "                          configuration." << ::std::endl;

    os << std::endl
       << "\033[1m--fetch-cache\033[0m \033[4mmode\033[0m        Comma-separated list of local fetch cache modes. The" << ::std::endl
       << "                          currently recognized modes are \033[1msrc\033[0m/\033[1mno-src\033[0m," << ::std::endl
       << "                          \033[1mtrust\033[0m/\033[1mno-trust\033[0m, and \033[1moffline\033[0m, with their semantics" << ::std::endl
       << "                          described below. The local cache mode can also be" << ::std::endl
       << "                          specified with the \033[1mBPKG_FETCH_CACHE\033[0m environment" << ::std::endl
       << "                          variable. Its value has the same format as this" << ::std::endl
       << "                          option." << ::std::endl
       << ::std::endl
       << "                          The \033[1msrc\033[0m/\033[1mno-src\033[0m mode enables/disables sharing of" << ::std::endl
       << "                          cached source directories for dependencies. If" << ::std::endl
       << "                          disabled, then private copies are made in the build" << ::std::endl
       << "                          configuration directories. The default for \033[1mbpkg\033[0m is to" << ::std::endl
       << "                          disable sharing, which is also the behavior if the" << ::std::endl
       << "                          fetch cache is disabled (\033[1m--no-fetch-cache\033[0m)." << ::std::endl
       << ::std::endl
       << "                          The \033[1mtrust\033[0m/\033[1mno-trust\033[0m mode enabled/disables caching of" << ::std::endl
       << "                          the repository authentication answers given by the" << ::std::endl
       << "                          user. The default is to enable caching. See" << ::std::endl
       << "                          \033[1mbpkg-repository-signing(1)\033[0m for background on" << ::std::endl
       << "                          repository authentication." << ::std::endl
       << ::std::endl
       << "                          The \033[1moffline\033[0m mode is equivalent to specifying the" << ::std::endl
       << "                          \033[1m--offline\033[0m option." << ::std::endl
       << ::std::endl
       << "                          Note that if this option and/or environment variable" << ::std::endl
       << "                          is specified during the configuration creation" << ::std::endl
       << "                          (\033[1mcfg-create(1)\033[0m), the effective \033[1msrc\033[0m and \033[1mtrust\033[0m modes" << ::std::endl
       << "                          are saved in the configuration and used as the" << ::std::endl
       << "                          defaults in the subsequent \033[1mbpkg\033[0m commands involving" << ::std::endl
       << "                          this configuration." << ::std::endl;

    os << std::endl
       << "\033[1m--fetch-cache-path\033[0m \033[4mdir\033[0m    The directory of the local fetch cache. Ideally, this" << ::std::endl
       << "                          directory should be on the same filesystem (UNIX) or" << ::std::endl
       << "                          volume (Windows) as the build configuration" << ::std::endl
       << "                          directories that will rely on this cache to allow the" << ::std::endl
       << "                          use of hard links. Failing that, the implementation" << ::std::endl
       << "                          will resort to copying, which may result in" << ::std::endl
       << "                          sub-optimal performance and inability to accurately" << ::std::endl
       << "                          track usage. The location of the cache can also be" << ::std::endl
       << "                          specified with the \033[1mBPKG_FETCH_CACHE_PATH\033[0m environment" << ::std::endl
       << "                          variable." << ::std::endl
       << ::std::endl
       << "                          If not explicitly specified, then the cache location" << ::std::endl
       << "                          is split across two directories: The non-precious" << ::std::endl
       << "                          data (packages and repository metadata) is placed" << ::std::endl
       << "                          into \033[1m$XDG_CACHE_HOME/build2/\033[0m or \033[1m$HOME/.cache/build2/\033[0m" << ::std::endl
       << "                          on UNIX and into \033[1m%LOCALAPPDATA%\\build2\\cache\\\033[0m on" << ::std::endl
       << "                          Windows. The semi-precious data (shared source" << ::std::endl
       << "                          directories) is placed into the \033[1m.build2/cache/\033[0m" << ::std::endl
       << "                          subdirectory of the user's home directory on all" << ::std::endl
       << "                          platforms. You can safely remove the non-precious" << ::std::endl
       << "                          data and while you won't lose any information if the" << ::std::endl
       << "                          semi-precious data is removed, you may end up with" << ::std::endl
       << "                          broken builds that will require manual repair." << ::std::endl
       << ::std::endl
       << "                          Note that if the cache location is explicitly" << ::std::endl
       << "                          specified with this option or the environment" << ::std::endl
       << "                          variable, then both types of data are placed into the" << ::std::endl
       << "                          specified directory. Note also that while there is" << ::std::endl
       << "                          currently no way to impose a size limit on the cache," << ::std::endl
       << "                          outdated cache entries are periodically removed." << ::std::endl;

    os << std::endl
       << "\033[1m--fetch-cache-session\033[0m \033[4mid\033[0m  The local fetch cache session. Specifying the same" << ::std::endl
       << "                          session id across multiple \033[1mbpkg\033[0m invocations allows" << ::std::endl
       << "                          eliminating repeated up-to-date checks of repository" << ::std::endl
       << "                          metadata. Any value, such as UUID, that is guaranteed" << ::std::endl
       << "                          not to clash with previous sessions can be used as a" << ::std::endl
       << "                          session id. The cache session can also be specified" << ::std::endl
       << "                          with the \033[1mBPKG_FETCH_CACHE_SESSION\033[0m environment" << ::std::endl
       << "                          variable." << ::std::endl;

    os << std::endl
       << "\033[1m--sqlite-synchronous\033[0m \033[4mmode\033[0m Synchronous mode for fetch cache and configuration" << ::std::endl
       << "                          databases. Valid values for this option are \033[1moff\033[0m," << ::std::endl
       << "                          \033[1mnormal\033[0m (default), \033[1mfull\033[0m, and \033[1mextra\033[0m. See SQLite" << ::std::endl
       << "                          documentation for details on the synchronous modes." << ::std::endl
       << ::std::endl
       << "                          Note that WAL (Write-Ahead Logging) journaling mode" << ::std::endl
       << "                          is used for fetch cache databases and rollback" << ::std::endl
       << "                          journaling mode for configuration databases." << ::std::endl;

    os << std::endl
       << "\033[1m--pkg-proxy\033[0m \033[4murl\033[0m           HTTP proxy server to use when fetching package" << ::std::endl
       << "                          manifests and archives from remote \033[1mpkg\033[0m repositories." << ::std::endl
       << "                          If specified, the proxy \033[4murl\033[0m must be in the" << ::std::endl
       << "                          \033[1mhttp://\033[0m\033[4mhost\033[0m[\033[1m:\033[0m\033[4mport\033[0m]\033[0m form. If \033[4mport\033[0m is omitted, 80 is" << ::std::endl
       << "                          used by default." << ::std::endl
       << ::std::endl
       << "                          Note that to allow caching, the proxied \033[1mhttps://\033[0m URLs" << ::std::endl
       << "                          are converted to \033[1mhttp://\033[0m in order to prevent the" << ::std::endl
       << "                          fetch program from tunneling (which is the standard" << ::std::endl
       << "                          approach for proxying HTTPS). If both HTTP and HTTPS" << ::std::endl
       << "                          repositories are used, it is assumed that the proxy" << ::std::endl
       << "                          server can figure out which URLs need to be converted" << ::std::endl
       << "                          back to \033[1mhttps://\033[0m based on the request information" << ::std::endl
       << "                          (for example, host name). For security, this" << ::std::endl
       << "                          mechanism should only be used with signed" << ::std::endl
       << "                          repositories or when the proxy is located inside a" << ::std::endl
       << "                          trusted network." << ::std::endl;

    os << std::endl
       << "\033[1m--git\033[0m \033[4mpath\033[0m                The git program to be used to fetch git repositories." << ::std::endl
       << "                          You can also specify additional options that should" << ::std::endl
       << "                          be passed to the git program with \033[1m--git-option\033[0m." << ::std::endl
       << ::std::endl
       << "                          If the git program is not explicitly specified, then" << ::std::endl
       << "                          \033[1mbpkg\033[0m will use \033[1mgit\033[0m by default." << ::std::endl;

    os << std::endl
       << "\033[1m--git-option\033[0m \033[4mopt\033[0m          Additional common option to be passed to the git" << ::std::endl
       << "                          program. Note that the common options are the ones" << ::std::endl
       << "                          that precede the \033[1mgit\033[0m command. See \033[1m--git\033[0m for more" << ::std::endl
       << "                          information on the git program. Repeat this option to" << ::std::endl
       << "                          specify multiple git options." << ::std::endl;

    os << std::endl
       << "\033[1m--sha256\033[0m \033[4mpath\033[0m             The sha256 program to be used to calculate SHA256" << ::std::endl
       << "                          sums. Currently, \033[1mbpkg\033[0m recognizes \033[1msha256\033[0m, \033[1msha256sum\033[0m," << ::std::endl
       << "                          and \033[1mshasum\033[0m. Note that the last component of \033[4mpath\033[0m must" << ::std::endl
       << "                          contain one of these names as a substring in order" << ::std::endl
       << "                          for \033[1mbpkg\033[0m to recognize which program is being used." << ::std::endl
       << "                          You can also specify additional options that should" << ::std::endl
       << "                          be passed to the sha256 program with \033[1m--sha256-option\033[0m." << ::std::endl
       << ::std::endl
       << "                          If the sha256 program is not specified, then \033[1mbpkg\033[0m" << ::std::endl
       << "                          will try to discover if one of the above programs is" << ::std::endl
       << "                          available and use that. Currently, \033[1mbpkg\033[0m has the" << ::std::endl
       << "                          following preference order: \033[1msha256\033[0m, \033[1msha256sum\033[0m, and" << ::std::endl
       << "                          \033[1mshasum\033[0m." << ::std::endl;

    os << std::endl
       << "\033[1m--sha256-option\033[0m \033[4mopt\033[0m       Additional option to be passed to the sha256 program." << ::std::endl
       << "                          See \033[1m--sha256\033[0m for more information on the sha256" << ::std::endl
       << "                          program. Repeat this option to specify multiple" << ::std::endl
       << "                          sha256 options." << ::std::endl;

    os << std::endl
       << "\033[1m--tar\033[0m \033[4mpath\033[0m                The tar program to be used to extract package" << ::std::endl
       << "                          archives. For example, \033[1mgtar\033[0m or \033[1mbsdtar\033[0m. You can also" << ::std::endl
       << "                          specify additional options that should be passed to" << ::std::endl
       << "                          the tar program with \033[1m--tar-option\033[0m. If the tar program" << ::std::endl
       << "                          is not explicitly specified, then \033[1mbpkg\033[0m will use \033[1mtar\033[0m" << ::std::endl
       << "                          by default." << ::std::endl;

    os << std::endl
       << "\033[1m--tar-option\033[0m \033[4mopt\033[0m          Additional option to be passed to the tar program." << ::std::endl
       << "                          See \033[1m--tar\033[0m for more information on the tar program." << ::std::endl
       << "                          Repeat this option to specify multiple tar options." << ::std::endl;

    os << std::endl
       << "\033[1m--openssl\033[0m \033[4mpath\033[0m            The openssl program to be used for crypto operations." << ::std::endl
       << "                          You can also specify additional options that should" << ::std::endl
       << "                          be passed to the openssl program with" << ::std::endl
       << "                          \033[1m--openssl-option\033[0m. If the openssl program is not" << ::std::endl
       << "                          explicitly specified, then \033[1mbpkg\033[0m will use \033[1mopenssl\033[0m by" << ::std::endl
       << "                          default." << ::std::endl
       << ::std::endl
       << "                          The \033[1m--openssl*\033[0m values can be optionally qualified" << ::std::endl
       << "                          with the openssl command in the \033[4mcommand\033[0m\033[1m:\033[0m\033[4mvalue\033[0m\033[0m form." << ::std::endl
       << "                          This makes the value only applicable to the specific" << ::std::endl
       << "                          command, for example:" << ::std::endl
       << ::std::endl
       << "                          bpkg rep-create                      \\" << ::std::endl
       << "                            --openssl pkeyutl:/path/to/openssl \\" << ::std::endl
       << "                            --openssl-option pkeyutl:-engine   \\" << ::std::endl
       << "                            --openssl-option pkeyutl:pkcs11    \\" << ::std::endl
       << "                            ..." << ::std::endl
       << ::std::endl
       << "                          Note that for \033[1mopenssl\033[0m versions prior to \033[1m3.0.0\033[0m \033[1mbpkg\033[0m" << ::std::endl
       << "                          uses the \033[1mrsautl\033[0m command instead of \033[1mpkeyutl\033[0m for the" << ::std::endl
       << "                          data signing and recovery operations." << ::std::endl
       << ::std::endl
       << "                          An unqualified value that contains a colon can be" << ::std::endl
       << "                          specified as qualified with an empty command, for" << ::std::endl
       << "                          example, \033[1m--openssl :C:\\bin\\openssl\033[0m. To see openssl" << ::std::endl
       << "                          commands executed by \033[1mbpkg\033[0m, use the verbose mode (\033[1m-v\033[0m" << ::std::endl
       << "                          option)." << ::std::endl;

    os << std::endl
       << "\033[1m--openssl-option\033[0m \033[4mopt\033[0m      Additional option to be passed to the openssl" << ::std::endl
       << "                          program. See \033[1m--openssl\033[0m for more information on the" << ::std::endl
       << "                          openssl program. The values can be optionally" << ::std::endl
       << "                          qualified with the openssl command, as discussed in" << ::std::endl
       << "                          \033[1m--openssl\033[0m. Repeat this option to specify multiple" << ::std::endl
       << "                          openssl options." << ::std::endl;

    os << std::endl
       << "\033[1m--auth\033[0m \033[4mtype\033[0m               Types of repositories to authenticate. Valid values" << ::std::endl
       << "                          for this option are \033[1mnone\033[0m, \033[1mremote\033[0m, \033[1mall\033[0m. By default" << ::std::endl
       << "                          only remote repositories are authenticated. You can" << ::std::endl
       << "                          request authentication of local repositories by" << ::std::endl
       << "                          passing \033[1mall\033[0m or disable authentication completely by" << ::std::endl
       << "                          passing \033[1mnone\033[0m." << ::std::endl;

    os << std::endl
       << "\033[1m--trust\033[0m \033[4mfingerprint\033[0m       Trust repository certificate with a SHA256" << ::std::endl
       << "                          \033[4mfingerprint\033[0m. Such a certificate is trusted" << ::std::endl
       << "                          automatically, without prompting the user for a" << ::std::endl
       << "                          confirmation. Repeat this option to trust multiple" << ::std::endl
       << "                          certificates. See \033[1mbpkg-repository-signing(1)\033[0m for" << ::std::endl
       << "                          background." << ::std::endl
       << ::std::endl
       << "                          Note that by default \033[1mopenssl\033[0m prints a SHA1" << ::std::endl
       << "                          fingerprint and to obtain a SHA256 one you will need" << ::std::endl
       << "                          to pass the \033[1m-sha256\033[0m option, for example:" << ::std::endl
       << ::std::endl
       << "                          openssl x509 -sha256 -fingerprint -noout -in cert.pem" << ::std::endl;

    os << std::endl
       << "\033[1m--trust-yes\033[0m               Assume the answer to all authentication prompts is" << ::std::endl
       << "                          \033[1myes\033[0m. See \033[1mbpkg-repository-signing(1)\033[0m for background." << ::std::endl;

    os << std::endl
       << "\033[1m--trust-no\033[0m                Assume the answer to all authentication prompts is" << ::std::endl
       << "                          \033[1mno\033[0m. See \033[1mbpkg-repository-signing(1)\033[0m for background." << ::std::endl;

    os << std::endl
       << "\033[1m--git-capabilities\033[0m \033[4mup\033[0m=\033[4mpc\033[0m  Protocol capabilities (\033[4mpc\033[0m) for a \033[1mgit\033[0m repository URL" << ::std::endl
       << "                          prefix (\033[4mup\033[0m). Valid values for the capabilities are" << ::std::endl
       << "                          \033[1mdumb\033[0m (no shallow clone support), \033[1msmart\033[0m (support for" << ::std::endl
       << "                          shallow clone, but not for fetching unadvertised" << ::std::endl
       << "                          commits), \033[1munadv\033[0m (support for shallow clone and for" << ::std::endl
       << "                          fetching unadvertised commits). For example:" << ::std::endl
       << ::std::endl
       << "                          bpkg build https://example.org/foo.git#master \\" << ::std::endl
       << "                            --git-capabilities https://example.org=smart" << ::std::endl
       << ::std::endl
       << "                          See \033[1mbpkg-repository-types(1)\033[0m for details on the \033[1mgit\033[0m" << ::std::endl
       << "                          protocol capabilities." << ::std::endl;

    os << std::endl
       << "\033[1m--pager\033[0m \033[4mpath\033[0m              The pager program to be used to show long text." << ::std::endl
       << "                          Commonly used pager programs are \033[1mless\033[0m and \033[1mmore\033[0m. You" << ::std::endl
       << "                          can also specify additional options that should be" << ::std::endl
       << "                          passed to the pager program with \033[1m--pager-option\033[0m. If" << ::std::endl
       << "                          an empty string is specified as the pager program," << ::std::endl
       << "                          then no pager will be used. If the pager program is" << ::std::endl
       << "                          not explicitly specified, then \033[1mbpkg\033[0m will try to use" << ::std::endl
       << "                          \033[1mless\033[0m. If it is not available, then no pager will be" << ::std::endl
       << "                          used." << ::std::endl;

    os << std::endl
       << "\033[1m--pager-option\033[0m \033[4mopt\033[0m        Additional option to be passed to the pager program." << ::std::endl
       << "                          See \033[1m--pager\033[0m for more information on the pager" << ::std::endl
       << "                          program. Repeat this option to specify multiple pager" << ::std::endl
       << "                          options." << ::std::endl;

    os << std::endl
       << "\033[1m--options-file\033[0m \033[4mfile\033[0m       Read additional options from \033[4mfile\033[0m. Each option should" << ::std::endl
       << "                          appear on a separate line optionally followed by" << ::std::endl
       << "                          space or equal sign (\033[1m=\033[0m) and an option value. Empty" << ::std::endl
       << "                          lines and lines starting with \033[1m#\033[0m are ignored. Option" << ::std::endl
       << "                          values can be enclosed in double (\033[1m\"\033[0m) or single (\033[1m'\033[0m)" << ::std::endl
       << "                          quotes to preserve leading and trailing whitespaces" << ::std::endl
       << "                          as well as to specify empty values. If the value" << ::std::endl
       << "                          itself contains trailing or leading quotes, enclose" << ::std::endl
       << "                          it with an extra pair of quotes, for example \033[1m'\"x\"'\033[0m." << ::std::endl
       << "                          Non-leading and non-trailing quotes are interpreted" << ::std::endl
       << "                          as being part of the option value." << ::std::endl
       << ::std::endl
       << "                          The semantics of providing options in a file is" << ::std::endl
       << "                          equivalent to providing the same set of options in" << ::std::endl
       << "                          the same order on the command line at the point where" << ::std::endl
       << "                          the \033[1m--options-file\033[0m option is specified except that" << ::std::endl
       << "                          the shell escaping and quoting is not required." << ::std::endl
       << "                          Repeat this option to specify more than one options" << ::std::endl
       << "                          file." << ::std::endl;

    os << std::endl
       << "\033[1m--default-options\033[0m \033[4mdir\033[0m     The directory to load additional default options" << ::std::endl
       << "                          files from." << ::std::endl;

    os << std::endl
       << "\033[1m--no-default-options\033[0m      Don't load default options files." << ::std::endl;

    os << std::endl
       << "\033[1m--keep-tmp\033[0m                Don't remove the \033[1mbpkg\033[0m's temporary directory at the" << ::std::endl
       << "                          end of the command execution and print its path at" << ::std::endl
       << "                          the verbosity level 2 or higher. This option is" << ::std::endl
       << "                          primarily useful for troubleshooting." << ::std::endl;

    p = ::bpkg::cli::usage_para::option;

    return p;
  }

  typedef
  std::map<std::string, void (*) (common_options&, ::bpkg::cli::scanner&)>
  _cli_common_options_map;

  static _cli_common_options_map _cli_common_options_map_;

  struct _cli_common_options_map_init
  {
    _cli_common_options_map_init ()
    {
      _cli_common_options_map_["-v"] =
      &::bpkg::cli::thunk< common_options, &common_options::v_ >;
      _cli_common_options_map_["-V"] =
      &::bpkg::cli::thunk< common_options, &common_options::V_ >;
      _cli_common_options_map_["--quiet"] =
      &::bpkg::cli::thunk< common_options, &common_options::quiet_ >;
      _cli_common_options_map_["-q"] =
      &::bpkg::cli::thunk< common_options, &common_options::quiet_ >;
      _cli_common_options_map_["--verbose"] =
      &::bpkg::cli::thunk< common_options, uint16_t, &common_options::verbose_,
        &common_options::verbose_specified_ >;
      _cli_common_options_map_["--stdout-format"] =
      &::bpkg::cli::thunk< common_options, bpkg::stdout_format, &common_options::stdout_format_,
        &common_options::stdout_format_specified_ >;
      _cli_common_options_map_["--jobs"] =
      &::bpkg::cli::thunk< common_options, size_t, &common_options::jobs_,
        &common_options::jobs_specified_ >;
      _cli_common_options_map_["-j"] =
      &::bpkg::cli::thunk< common_options, size_t, &common_options::jobs_,
        &common_options::jobs_specified_ >;
      _cli_common_options_map_["--no-result"] =
      &::bpkg::cli::thunk< common_options, &common_options::no_result_ >;
      _cli_common_options_map_["--structured-result"] =
      &::bpkg::cli::thunk< common_options, string, &common_options::structured_result_,
        &common_options::structured_result_specified_ >;
      _cli_common_options_map_["--progress"] =
      &::bpkg::cli::thunk< common_options, &common_options::progress_ >;
      _cli_common_options_map_["--no-progress"] =
      &::bpkg::cli::thunk< common_options, &common_options::no_progress_ >;
      _cli_common_options_map_["--diag-color"] =
      &::bpkg::cli::thunk< common_options, &common_options::diag_color_ >;
      _cli_common_options_map_["--no-diag-color"] =
      &::bpkg::cli::thunk< common_options, &common_options::no_diag_color_ >;
      _cli_common_options_map_["--build"] =
      &::bpkg::cli::thunk< common_options, path, &common_options::build_,
        &common_options::build_specified_ >;
      _cli_common_options_map_["--build-option"] =
      &::bpkg::cli::thunk< common_options, strings, &common_options::build_option_,
        &common_options::build_option_specified_ >;
      _cli_common_options_map_["--fetch"] =
      &::bpkg::cli::thunk< common_options, path, &common_options::fetch_,
        &common_options::fetch_specified_ >;
      _cli_common_options_map_["--fetch-option"] =
      &::bpkg::cli::thunk< common_options, strings, &common_options::fetch_option_,
        &common_options::fetch_option_specified_ >;
      _cli_common_options_map_["--curl"] =
      &::bpkg::cli::thunk< common_options, path, &common_options::curl_,
        &common_options::curl_specified_ >;
      _cli_common_options_map_["--curl-option"] =
      &::bpkg::cli::thunk< common_options, strings, &common_options::curl_option_,
        &common_options::curl_option_specified_ >;
      _cli_common_options_map_["--fetch-timeout"] =
      &::bpkg::cli::thunk< common_options, size_t, &common_options::fetch_timeout_,
        &common_options::fetch_timeout_specified_ >;
      _cli_common_options_map_["--offline"] =
      &::bpkg::cli::thunk< common_options, &common_options::offline_ >;
      _cli_common_options_map_["--no-fetch-cache"] =
      &::bpkg::cli::thunk< common_options, &common_options::no_fetch_cache_ >;
      _cli_common_options_map_["--fetch-cache"] =
      &::bpkg::cli::thunk< common_options, string, &common_options::fetch_cache_,
        &common_options::fetch_cache_specified_ >;
      _cli_common_options_map_["--fetch-cache-path"] =
      &::bpkg::cli::thunk< common_options, dir_path, &common_options::fetch_cache_path_,
        &common_options::fetch_cache_path_specified_ >;
      _cli_common_options_map_["--fetch-cache-session"] =
      &::bpkg::cli::thunk< common_options, string, &common_options::fetch_cache_session_,
        &common_options::fetch_cache_session_specified_ >;
      _cli_common_options_map_["--sqlite-synchronous"] =
      &::bpkg::cli::thunk< common_options, bpkg::sqlite_synchronous, &common_options::sqlite_synchronous_,
        &common_options::sqlite_synchronous_specified_ >;
      _cli_common_options_map_["--pkg-proxy"] =
      &::bpkg::cli::thunk< common_options, butl::url, &common_options::pkg_proxy_,
        &common_options::pkg_proxy_specified_ >;
      _cli_common_options_map_["--git"] =
      &::bpkg::cli::thunk< common_options, path, &common_options::git_,
        &common_options::git_specified_ >;
      _cli_common_options_map_["--git-option"] =
      &::bpkg::cli::thunk< common_options, strings, &common_options::git_option_,
        &common_options::git_option_specified_ >;
      _cli_common_options_map_["--sha256"] =
      &::bpkg::cli::thunk< common_options, path, &common_options::sha256_,
        &common_options::sha256_specified_ >;
      _cli_common_options_map_["--sha256-option"] =
      &::bpkg::cli::thunk< common_options, strings, &common_options::sha256_option_,
        &common_options::sha256_option_specified_ >;
      _cli_common_options_map_["--tar"] =
      &::bpkg::cli::thunk< common_options, path, &common_options::tar_,
        &common_options::tar_specified_ >;
      _cli_common_options_map_["--tar-option"] =
      &::bpkg::cli::thunk< common_options, strings, &common_options::tar_option_,
        &common_options::tar_option_specified_ >;
      _cli_common_options_map_["--openssl"] =
      &::bpkg::cli::thunk< common_options, qualified_option<openssl_commands, path>, &common_options::openssl_,
        &common_options::openssl_specified_ >;
      _cli_common_options_map_["--openssl-option"] =
      &::bpkg::cli::thunk< common_options, qualified_option<openssl_commands, strings>, &common_options::openssl_option_,
        &common_options::openssl_option_specified_ >;
      _cli_common_options_map_["--auth"] =
      &::bpkg::cli::thunk< common_options, bpkg::auth, &common_options::auth_,
        &common_options::auth_specified_ >;
      _cli_common_options_map_["--trust"] =
      &::bpkg::cli::thunk< common_options, std::set<string, icase_compare_string>, &common_options::trust_,
        &common_options::trust_specified_ >;
      _cli_common_options_map_["--trust-yes"] =
      &::bpkg::cli::thunk< common_options, &common_options::trust_yes_ >;
      _cli_common_options_map_["--trust-no"] =
      &::bpkg::cli::thunk< common_options, &common_options::trust_no_ >;
      _cli_common_options_map_["--git-capabilities"] =
      &::bpkg::cli::thunk< common_options, git_capabilities_map, &common_options::git_capabilities_,
        &common_options::git_capabilities_specified_ >;
      _cli_common_options_map_["--pager"] =
      &::bpkg::cli::thunk< common_options, string, &common_options::pager_,
        &common_options::pager_specified_ >;
      _cli_common_options_map_["--pager-option"] =
      &::bpkg::cli::thunk< common_options, strings, &common_options::pager_option_,
        &common_options::pager_option_specified_ >;
      _cli_common_options_map_["--options-file"] =
      &::bpkg::cli::thunk< common_options, string, &common_options::options_file_,
        &common_options::options_file_specified_ >;
      _cli_common_options_map_["--default-options"] =
      &::bpkg::cli::thunk< common_options, dir_path, &common_options::default_options_,
        &common_options::default_options_specified_ >;
      _cli_common_options_map_["--no-default-options"] =
      &::bpkg::cli::thunk< common_options, &common_options::no_default_options_ >;
      _cli_common_options_map_["--keep-tmp"] =
      &::bpkg::cli::thunk< common_options, &common_options::keep_tmp_ >;
    }
  };

  static _cli_common_options_map_init _cli_common_options_map_init_;

  bool common_options::
  _parse (const char* o, ::bpkg::cli::scanner& s)
  {
    _cli_common_options_map::const_iterator i (_cli_common_options_map_.find (o));

    if (i != _cli_common_options_map_.end ())
    {
      (*(i->second)) (*this, s);
      return true;
    }

    return false;
  }
}

namespace bpkg
{
  ::bpkg::cli::usage_para
  print_bpkg_common_options_usage (::std::ostream& os, ::bpkg::cli::usage_para p)
  {
    CLI_POTENTIALLY_UNUSED (os);

    if (p != ::bpkg::cli::usage_para::none)
      os << ::std::endl;

    os << "\033[1mSYNOPSIS\033[0m" << ::std::endl
       << ::std::endl
       << "\033[1mbpkg\033[0m [\033[4mcommon-options\033[0m] ...\033[0m" << ::std::endl
       << ::std::endl
       << "\033[1mDESCRIPTION\033[0m" << ::std::endl
       << ::std::endl
       << "The common options control behavior that is common to all or most of the \033[1mbpkg\033[0m" << ::std::endl
       << "commands. They can be specified either before the command or after, together" << ::std::endl
       << "with the command-specific options." << ::std::endl;

    p = ::bpkg::common_options::print_usage (os, ::bpkg::cli::usage_para::text);

    if (p != ::bpkg::cli::usage_para::none)
      os << ::std::endl;

    os << "\033[1mJSON OUTPUT\033[0m" << ::std::endl
       << ::std::endl
       << "Commands that support the JSON output specify their formats as a serialized" << ::std::endl
       << "representation of a C++ \033[1mstruct\033[0m or an array thereof. For example:" << ::std::endl
       << ::std::endl
       << "struct package" << ::std::endl
       << "{" << ::std::endl
       << "  string name;" << ::std::endl
       << "};" << ::std::endl
       << ::std::endl
       << "struct configuration" << ::std::endl
       << "{" << ::std::endl
       << "  uint64_t         id;" << ::std::endl
       << "  string           path;" << ::std::endl
       << "  optional<string> name;" << ::std::endl
       << "  bool             default;" << ::std::endl
       << "  vector<package>  packages;" << ::std::endl
       << "};" << ::std::endl
       << ::std::endl
       << "An example of the serialized JSON representation of \033[1mstruct\033[0m \033[1mconfiguration\033[0m:" << ::std::endl
       << ::std::endl
       << "{" << ::std::endl
       << "  \"id\": 1," << ::std::endl
       << "  \"path\": \"/tmp/hello-gcc\"," << ::std::endl
       << "  \"name\": \"gcc\"," << ::std::endl
       << "  \"default\": true," << ::std::endl
       << "  \"packages\": [" << ::std::endl
       << "    {" << ::std::endl
       << "      \"name\": \"hello\"" << ::std::endl
       << "    }" << ::std::endl
       << "  ]" << ::std::endl
       << "}" << ::std::endl
       << ::std::endl
       << "This sections provides details on the overall properties of such formats and" << ::std::endl
       << "the semantics of the \033[1mstruct\033[0m serialization." << ::std::endl
       << ::std::endl
       << "The order of members in a JSON object is fixed as specified in the" << ::std::endl
       << "corresponding \033[1mstruct\033[0m. While new members may be added in the future (and should" << ::std::endl
       << "be ignored by older consumers), the semantics of the existing members" << ::std::endl
       << "(including whether the top-level entry is an object or array) may not change." << ::std::endl
       << ::std::endl
       << "An object member is required unless its type is \033[1moptional<>\033[0m, \033[1mbool\033[0m, or \033[1mvector<>\033[0m" << ::std::endl
       << "(array). For \033[1mbool\033[0m members absent means \033[1mfalse\033[0m. For \033[1mvector<>\033[0m members absent means" << ::std::endl
       << "empty. An empty top-level array is always present." << ::std::endl
       << ::std::endl
       << "For example, the following JSON text is a possible serialization of the above" << ::std::endl
       << "\033[1mstruct\033[0m \033[1mconfiguration\033[0m:" << ::std::endl
       << ::std::endl
       << "{" << ::std::endl
       << "  \"id\": 1," << ::std::endl
       << "  \"path\": \"/tmp/hello-gcc\"" << ::std::endl
       << "}" << ::std::endl;

    os << std::endl
       << "\033[1mDEFAULT OPTIONS FILES\033[0m" << ::std::endl
       << ::std::endl
       << "See \033[1mbpkg-default-options-files(1)\033[0m for an overview of the default options files." << ::std::endl
       << "The following common options cannot be specified in the default options files:" << ::std::endl
       << ::std::endl
       << "--fetch-cache-session" << ::std::endl;

    p = ::bpkg::cli::usage_para::text;

    return p;
  }

  ::bpkg::cli::usage_para
  print_bpkg_common_options_long_usage (::std::ostream& os, ::bpkg::cli::usage_para p)
  {
    CLI_POTENTIALLY_UNUSED (os);

    if (p != ::bpkg::cli::usage_para::none)
      os << ::std::endl;

    os << "\033[1mSYNOPSIS\033[0m" << ::std::endl
       << ::std::endl
       << "\033[1mbpkg\033[0m [\033[4mcommon-options\033[0m] ...\033[0m" << ::std::endl
       << ::std::endl
       << "\033[1mDESCRIPTION\033[0m" << ::std::endl
       << ::std::endl
       << "The common options control behavior that is common to all or most of the \033[1mbpkg\033[0m" << ::std::endl
       << "commands. They can be specified either before the command or after, together" << ::std::endl
       << "with the command-specific options." << ::std::endl;

    p = ::bpkg::common_options::print_long_usage (os, ::bpkg::cli::usage_para::text);

    if (p != ::bpkg::cli::usage_para::none)
      os << ::std::endl;

    os << "\033[1mJSON OUTPUT\033[0m" << ::std::endl
       << ::std::endl
       << "Commands that support the JSON output specify their formats as a serialized" << ::std::endl
       << "representation of a C++ \033[1mstruct\033[0m or an array thereof. For example:" << ::std::endl
       << ::std::endl
       << "struct package" << ::std::endl
       << "{" << ::std::endl
       << "  string name;" << ::std::endl
       << "};" << ::std::endl
       << ::std::endl
       << "struct configuration" << ::std::endl
       << "{" << ::std::endl
       << "  uint64_t         id;" << ::std::endl
       << "  string           path;" << ::std::endl
       << "  optional<string> name;" << ::std::endl
       << "  bool             default;" << ::std::endl
       << "  vector<package>  packages;" << ::std::endl
       << "};" << ::std::endl
       << ::std::endl
       << "An example of the serialized JSON representation of \033[1mstruct\033[0m \033[1mconfiguration\033[0m:" << ::std::endl
       << ::std::endl
       << "{" << ::std::endl
       << "  \"id\": 1," << ::std::endl
       << "  \"path\": \"/tmp/hello-gcc\"," << ::std::endl
       << "  \"name\": \"gcc\"," << ::std::endl
       << "  \"default\": true," << ::std::endl
       << "  \"packages\": [" << ::std::endl
       << "    {" << ::std::endl
       << "      \"name\": \"hello\"" << ::std::endl
       << "    }" << ::std::endl
       << "  ]" << ::std::endl
       << "}" << ::std::endl
       << ::std::endl
       << "This sections provides details on the overall properties of such formats and" << ::std::endl
       << "the semantics of the \033[1mstruct\033[0m serialization." << ::std::endl
       << ::std::endl
       << "The order of members in a JSON object is fixed as specified in the" << ::std::endl
       << "corresponding \033[1mstruct\033[0m. While new members may be added in the future (and should" << ::std::endl
       << "be ignored by older consumers), the semantics of the existing members" << ::std::endl
       << "(including whether the top-level entry is an object or array) may not change." << ::std::endl
       << ::std::endl
       << "An object member is required unless its type is \033[1moptional<>\033[0m, \033[1mbool\033[0m, or \033[1mvector<>\033[0m" << ::std::endl
       << "(array). For \033[1mbool\033[0m members absent means \033[1mfalse\033[0m. For \033[1mvector<>\033[0m members absent means" << ::std::endl
       << "empty. An empty top-level array is always present." << ::std::endl
       << ::std::endl
       << "For example, the following JSON text is a possible serialization of the above" << ::std::endl
       << "\033[1mstruct\033[0m \033[1mconfiguration\033[0m:" << ::std::endl
       << ::std::endl
       << "{" << ::std::endl
       << "  \"id\": 1," << ::std::endl
       << "  \"path\": \"/tmp/hello-gcc\"" << ::std::endl
       << "}" << ::std::endl;

    os << std::endl
       << "\033[1mDEFAULT OPTIONS FILES\033[0m" << ::std::endl
       << ::std::endl
       << "See \033[1mbpkg-default-options-files(1)\033[0m for an overview of the default options files." << ::std::endl
       << "The following common options cannot be specified in the default options files:" << ::std::endl
       << ::std::endl
       << "--fetch-cache-session" << ::std::endl;

    p = ::bpkg::cli::usage_para::text;

    return p;
  }
}

// Begin epilogue.
//
//
// End epilogue.

